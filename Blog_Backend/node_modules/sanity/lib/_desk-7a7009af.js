function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { cO as EMPTY_PARAMS$1, B as route } from './_prepareConfig-56d87958.js';
import 'rxjs';
import 'rxjs/operators';
import { lazy } from 'react';
import 'react/jsx-runtime';
import { MasterDetailIcon } from '@sanity/icons';
import { omit } from 'lodash';
import '@sanity/ui';
import 'history';
import '@sanity/bifur-client';
import 'react-is';
import '@sanity/schema';
import '@sanity/schema/_internal';
import '@sanity/validation';
import 'react-rx';
import 'shallow-equals';
import '@sanity/types';
import '@sanity/color';
import '@sanity/image-url';
import '@sanity/util/paths';
import 'react-fast-compare';
import '@sanity/util/content';
import '@sanity/portable-text-editor';
import 'scroll-into-view-if-needed';
import '@reach/auto-id';
import '@sanity/util/legacyDateFormat';
import 'date-fns';
import 'speakingurl';
import { uuid } from '@sanity/uuid';
import 'get-random-values-esm';
import '@sanity/asset-utils';
import 'exif-component';
import 'react-dom';
import 'pluralize-esm';
import '@sanity/mutator';
import 'json-reduce';
import 'rxjs-exhaustmap-with-trailing';
import 'dataloader';
import 'raf';
import 'groq-js';
import 'rxjs-etc/operators';
import { c as createPlugin } from './_createPlugin-6e6e8fa6.js';
import 'mendoza';
import '@sanity/diff';
import './_DocumentTypeList-43c73c38.js';
import 'nanoid';
import '@sanity/generate-help-url';
const state = {
  activePanes: []
};

function setActivePanes(panes) {
  state.activePanes = panes;
}

function getIntentState(intent, params, routerState, payload) {
  var _a;

  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || uuid();
  const isTemplate = intent === "create" && params.template;

  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object") continue;

    if (((_a = pane.canHandleIntent) == null ? void 0 : _a.call(pane, intent, params, {
      pane,
      index: i
    })) || pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? {
        template: params.template
      } : EMPTY_PARAMS$1;
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }

  return {
    intent,
    params,
    payload
  };
}

const EMPTY_PARAMS = {};

function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}

function encodePanesSegment(panes) {
  return (panes || []).map(group => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}

function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}

function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}

function toPath(panes) {
  return encodePanesSegment(panes);
}

const router = route.create("/", [route.intents("/intent"), route.create("/edit/:type/:editDocumentId", [route.create({
  path: "/:params",
  transform: {
    params: {
      toState: legacyEditParamsToState,
      toPath: legacyEditParamsToPath
    }
  }
})]), route.create({
  path: "/:panes",
  children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
  transform: {
    panes: {
      toState,
      toPath
    }
  }
})]);
const panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;

const isParam = str => /^[a-z0-9]+=[^=]+/i.test(str);

const isPayload = str => /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);

const exclusiveParams = ["view", "since", "rev"];
const isTruthy = Boolean;

function parseChunks(chunks, initial) {
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = _objectSpread(_objectSpread({}, pane.params), {}, {
        [decodeURIComponent(key)]: decodeURIComponent(value)
      });
    } else if (isPayload(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }

    return pane;
  }, _objectSpread(_objectSpread({}, initial), {}, {
    params: EMPTY_PARAMS,
    payload: void 0
  }));
}

function encodeChunks(pane, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : btoa(JSON.stringify(payload));
  const encodedParams = Object.entries(params).filter(entry => {
    var _a;

    const [key, value] = entry;
    if (!value) return false;
    if (paneIsFirstSibling) return true;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key)) return false;
    return true;
  }).map(_ref => {
    let [key, value] = _ref;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}

function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }

  return str.split(";").map(group => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map(segment => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map(sibling => _objectSpread(_objectSpread(_objectSpread({}, firstSibling), sibling), {}, {
      id: sibling.id || firstSibling.id,
      params: _objectSpread(_objectSpread({}, omit(firstSibling.params, exclusiveParams)), sibling.params),
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter(group => group.length > 0);
}

function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;

  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];

    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }

    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    });
    buffer = buffer.slice(match.length);
  }

  return [chunks];
}

function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}

function tryParseBase64Payload(data) {
  return data ? tryParsePayload(atob(data)) : void 0;
}

const deskTool = createPlugin(options => ({
  name: "@sanity/desk-tool",
  tools: [{
    name: (options == null ? void 0 : options.name) || "desk",
    title: (options == null ? void 0 : options.title) || "Desk",
    icon: (options == null ? void 0 : options.icon) || MasterDetailIcon,
    component: lazy(() => import('./_index-ba042112.js')),
    canHandleIntent: (intent, params) => {
      return Boolean(intent === "edit" && params.id || intent === "create" && params.type || intent === "create" && params.template);
    },
    getIntentState,
    options,
    router
  }]
}));
export { deskTool as d, setActivePanes as s };
//# sourceMappingURL=_desk-7a7009af.js.map
