import React, { useCallback, useMemo, useRef } from 'react';
import { PatchEvent, set, unset } from '../../patch';
import { useDidUpdate } from '../../hooks/useDidUpdate';
import { useFormCallbacks } from '../../studio/contexts/FormCallbacks';
import { isBooleanSchemaType, isNumberSchemaType } from '@sanity/types';
/**
 * Responsible for creating inputProps and fieldProps to pass to ´renderInput´ and ´renderField´ for a primitive field/input
 * @param props - Component props
 */
export function PrimitiveField(props) {
    const { member, renderInput, renderField } = props;
    const focusRef = useRef();
    const { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
    useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
        if (!hadFocus && hasFocus) {
            focusRef.current?.focus();
        }
    });
    const handleBlur = useCallback((event) => {
        onPathBlur(member.field.path);
    }, [member.field.path, onPathBlur]);
    const handleFocus = useCallback((event) => {
        onPathFocus(member.field.path);
    }, [member.field.path, onPathFocus]);
    const handleChange = useCallback((event) => {
        onChange(PatchEvent.from(event).prefixAll(member.name));
    }, [onChange, member.name]);
    const handleNativeChange = useCallback((event) => {
        let inputValue = event.currentTarget.value;
        if (isNumberSchemaType(member.field.schemaType)) {
            inputValue = event.currentTarget.valueAsNumber;
        }
        else if (isBooleanSchemaType(member.field.schemaType)) {
            inputValue = event.currentTarget.checked;
        }
        // `valueAsNumber` returns `NaN` on empty input
        const hasEmptyValue = inputValue === '' || (typeof inputValue === 'number' && isNaN(inputValue));
        onChange(PatchEvent.from(hasEmptyValue ? unset() : set(inputValue)).prefixAll(member.name));
    }, [member.name, member.field.schemaType, onChange]);
    const validationError = useMemo(() => member.field.validation
        .filter((item) => item.level === 'error')
        .map((item) => item.message)
        .join('\n'), [member.field.validation]) || undefined;
    const elementProps = useMemo(() => ({
        onBlur: handleBlur,
        onFocus: handleFocus,
        id: member.field.id,
        ref: focusRef,
        onChange: handleNativeChange,
        value: String(member.field.value || ''),
        readOnly: Boolean(member.field.readOnly),
        placeholder: member.field.schemaType.placeholder,
    }), [
        handleBlur,
        handleFocus,
        handleNativeChange,
        member.field.id,
        member.field.readOnly,
        member.field.schemaType.placeholder,
        member.field.value,
    ]);
    const inputProps = useMemo(() => {
        return {
            value: member.field.value,
            readOnly: member.field.readOnly,
            schemaType: member.field.schemaType,
            changed: member.field.changed,
            id: member.field.id,
            path: member.field.path,
            focused: member.field.focused,
            level: member.field.level,
            onChange: handleChange,
            validation: member.field.validation,
            presence: member.field.presence,
            validationError,
            elementProps,
        };
    }, [
        member.field.value,
        member.field.readOnly,
        member.field.schemaType,
        member.field.changed,
        member.field.id,
        member.field.path,
        member.field.focused,
        member.field.level,
        member.field.validation,
        member.field.presence,
        handleChange,
        validationError,
        elementProps,
    ]);
    const renderedInput = useMemo(() => renderInput(inputProps), [inputProps, renderInput]);
    const fieldProps = useMemo(() => {
        return {
            name: member.name,
            index: member.index,
            level: member.field.level,
            value: member.field.value,
            schemaType: member.field.schemaType,
            title: member.field.schemaType.title,
            description: member.field.schemaType.description,
            inputId: member.field.id,
            path: member.field.path,
            validation: member.field.validation,
            presence: member.field.presence,
            children: renderedInput,
            changed: member.field.changed,
            inputProps: inputProps,
        };
    }, [
        member.name,
        member.index,
        member.field.level,
        member.field.value,
        member.field.schemaType,
        member.field.id,
        member.field.path,
        member.field.validation,
        member.field.presence,
        member.field.changed,
        renderedInput,
        inputProps,
    ]);
    return React.createElement(React.Fragment, null, renderField(fieldProps));
}
//# sourceMappingURL=PrimitiveField.js.map