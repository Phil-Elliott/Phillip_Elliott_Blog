import { isArraySchemaType, isObjectSchemaType, } from '@sanity/types';
import { isEmpty, randomKey, resolveTypeName } from '@sanity/util/content';
import { isRecord } from './util/isRecord';
import { validateInitialObjectValue } from './validate';
import deepAssign from './util/deepAssign';
export function isBuilder(template) {
    return isRecord(template) && typeof template.serialize === 'function';
}
// returns the "resolved" value from an initial value property (e.g. type.initialValue)
// eslint-disable-next-line require-await
export async function resolveValue(initialValueOpt, params, context) {
    return typeof initialValueOpt === 'function'
        ? initialValueOpt(params, context)
        : initialValueOpt;
}
export async function resolveInitialValue(schema, template, params = {}, context) {
    // Template builder?
    if (isBuilder(template)) {
        return resolveInitialValue(schema, template.serialize(), params, context);
    }
    const { id, schemaType: schemaTypeName, value } = template;
    if (!value) {
        throw new Error(`Template "${id}" has invalid "value" property`);
    }
    let resolvedValue = await resolveValue(value, params, context);
    if (!isRecord(resolvedValue)) {
        throw new Error(`Template "${id}" has invalid "value" property - must be a plain object or a resolver function returning a plain object`);
    }
    // validate default document initial values
    resolvedValue = validateInitialObjectValue(resolvedValue, template);
    // Get deep initial values from schema types (note: the initial value from template overrides the types)
    const schemaType = schema.get(schemaTypeName);
    if (!schemaType) {
        throw new Error(`Could not find schema type with name "${schemaTypeName}".`);
    }
    const newValue = deepAssign((await resolveInitialValueForType(schemaType, params, DEFAULT_MAX_RECURSION_DEPTH, context)) ||
        {}, resolvedValue);
    // revalidate and return new initial values
    // todo: would be better to do validation as part of type resolution
    return validateInitialObjectValue(newValue, template);
}
export function getItemType(arrayType, item) {
    const itemTypeName = resolveTypeName(item);
    return itemTypeName === 'object' && arrayType.of.length === 1
        ? arrayType.of[0]
        : arrayType.of.find((memberType) => memberType.name === itemTypeName);
}
export const DEFAULT_MAX_RECURSION_DEPTH = 10;
/**
 * Resolve initial value for the given schema type (recursively)
 */
export function resolveInitialValueForType(
/**
 * This is the name of the document.
 */
type, 
/**
 * Params is a sanity context object passed to every initial value function.
 */
params, 
/**
 * Maximum recursion depth (default 9).
 */
maxDepth = DEFAULT_MAX_RECURSION_DEPTH, context) {
    if (maxDepth <= 0) {
        return Promise.resolve(undefined);
    }
    if (isObjectSchemaType(type)) {
        return resolveInitialObjectValue(type, params, maxDepth, context);
    }
    if (isArraySchemaType(type)) {
        return resolveInitialArrayValue(type, params, maxDepth, context);
    }
    return resolveValue(type.initialValue, params, context);
}
async function resolveInitialArrayValue(type, params, maxDepth, context) {
    const initialArray = await resolveValue(type.initialValue, undefined, context);
    if (!Array.isArray(initialArray)) {
        return undefined;
    }
    return Promise.all(initialArray.map(async (initialItem) => {
        const itemType = getItemType(type, initialItem);
        return isObjectSchemaType(itemType)
            ? {
                ...initialItem,
                ...(await resolveInitialValueForType(itemType, params, maxDepth - 1, context)),
                _key: randomKey(),
            }
            : initialItem;
    }));
}
export async function resolveInitialObjectValue(type, params, maxDepth, context) {
    const initialObject = {
        ...((await resolveValue(type.initialValue, params, context)) || {}),
    };
    const fieldValues = {};
    await Promise.all(type.fields.map(async (field) => {
        const initialFieldValue = await resolveInitialValueForType(field.type, params, maxDepth - 1, context);
        if (initialFieldValue !== undefined && initialFieldValue !== null) {
            fieldValues[field.name] = initialFieldValue;
        }
    }));
    const merged = deepAssign(fieldValues, initialObject);
    if (isEmpty(merged)) {
        return undefined;
    }
    if (type.name !== 'object') {
        merged._type = type.name;
    }
    return merged;
}
//# sourceMappingURL=resolve.js.map