/// <reference types="jest" />
import { SanityClient } from '@sanity/client';
import { Path, Schema, SchemaType } from '@sanity/types';
import React, { FocusEvent } from 'react';
import { NodePresence, NodeValidation, PatchArg, PatchEvent } from '../../src/form';
import { FormState } from '../../src/form/store/useFormState';
import { TestRenderProps } from './types';
export interface TestRenderInputContext {
    client: SanityClient;
    formState: FormState;
}
export interface TestRenderInputProps<ElementProps> {
    focusPath: Path;
    id: string;
    level: number;
    onBlur: (event: FocusEvent) => void;
    onChange: (path: PatchArg | PatchEvent) => void;
    onFocus: (event: FocusEvent) => void;
    onPathBlur: (path: Path) => void;
    onPathFocus: (path: Path) => void;
    path: Path;
    presence: NodePresence[];
    readOnly: boolean | undefined;
    schemaType: SchemaType;
    validation: NodeValidation[];
    value: unknown;
    elementProps: ElementProps;
}
export declare type TestRenderInputCallback<ElementProps> = (inputProps: TestRenderInputProps<ElementProps>, context: TestRenderInputContext) => React.ReactElement;
export declare function renderInput(props: {
    fieldDefinition: Schema.FieldDefinition;
    props?: TestRenderProps;
    render: TestRenderInputCallback<any>;
}): Promise<{
    focusRef: {
        current: null;
    };
    onBlur: jest.Mock<any, any>;
    onChange: jest.Mock<any, any>;
    onNativeChange: jest.Mock<any, any[]>;
    onFocus: jest.Mock<any, any>;
    onPathBlur: jest.Mock<any, any>;
    onPathFocus: jest.Mock<any, any>;
    onFieldGroupSelect: jest.Mock<any, any>;
    onSetFieldSetCollapsed: jest.Mock<any, any>;
    rerender: (subsequentRender: TestRenderInputCallback<any>) => void;
    result: import("@testing-library/react").RenderResult<typeof import("@testing-library/dom/types/queries"), HTMLElement>;
}>;
//# sourceMappingURL=renderInput.d.ts.map