'use strict';

const _excluded = ["id", "type"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jsxRuntime = require('react/jsx-runtime');

var React = require('react');

var ui = require('@sanity/ui');

require('@sanity/icons');

var lodash = require('lodash');

var prepareConfig = require('./_prepareConfig-2f1df9bf.cjs');

require('history');

require('rxjs');

var operators = require('rxjs/operators');

require('@sanity/bifur-client');

require('react-is');

require('@sanity/schema');

require('@sanity/schema/_internal');

require('@sanity/validation');

require('date-fns');

require('pluralize-esm');

require('react-rx');

require('@sanity/image-url');

require('@sanity/types');

require('shallow-equals');

require('@sanity/mutator');

require('json-reduce');

require('rxjs-exhaustmap-with-trailing');

require('@sanity/util/content');

require('@sanity/util/paths');

require('dataloader');

require('raf');

require('groq-js');

require('rxjs-etc/operators');

require('mendoza');

require('@sanity/diff');

require('@sanity/color');

require('react-fast-compare');

require('@sanity/portable-text-editor');

require('scroll-into-view-if-needed');

require('@reach/auto-id');

require('@sanity/util/legacyDateFormat');

require('speakingurl');

var uuid = require('@sanity/uuid');

require('get-random-values-esm');

require('@sanity/asset-utils');

require('exif-component');

require('react-dom');

var createStructureBuilder = require('./_createStructureBuilder-ad600465.cjs');

var desk = require('./_desk-c9a7b09d.cjs');

require('@sanity/generate-help-url');

require('nanoid');

require('@sanity/client');

require('@juggle/resize-observer');

require('nano-pubsub');

require('styled-components');

require('observable-callback');

require('debug');

require('react-refractor');

require('refractor/lang/bash');

require('refractor/lang/javascript');

require('refractor/lang/json');

require('refractor/lang/jsx');

require('refractor/lang/typescript');

require('use-hot-module-reload');

require('classnames');

require('use-device-pixel-ratio');

require('color2k');

require('react-sortable-hoc');

require('@sanity/block-tools');

require('diff-match-patch');

require('date-fns/isValid');

require('react-focus-lock');

require('date-fns/formatDistanceToNow');

require('is-hotkey');

require('react-copy-to-clipboard');

require('sanity-diff-patch');

require('@rexxars/react-json-inspector');

require('hashlru');

require('framer-motion');

require('react-props-stream');

require('@sanity/logos');

require('@portabletext/react');

require('./_DocumentTypeList-03e0e0a7.cjs');

require('./_createPlugin-904247f9.cjs');

function DeskToolProvider(_ref) {
  let {
    defaultDocumentNode,
    structure: resolveStructure,
    children
  } = _ref;
  const [layoutCollapsed, setLayoutCollapsed] = React.useState(false);
  const source = prepareConfig.useSource();
  const configContext = createStructureBuilder.useConfigContextFromSource(source);
  const S = React.useMemo(() => {
    return createStructureBuilder.createStructureBuilder({
      defaultDocumentNode,
      source
    });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = React.useMemo(() => {
    if (resolveStructure) return resolveStructure(S, configContext);
    return S.defaults();
  }, [S, resolveStructure, configContext]);
  return /* @__PURE__ */jsxRuntime.jsx(prepareConfig.DeskToolContext.Provider, {
    value: React.useMemo(() => {
      return {
        features: {
          backButton: layoutCollapsed,
          reviewChanges: !layoutCollapsed,
          splitPanes: !layoutCollapsed,
          splitViews: !layoutCollapsed
        },
        layoutCollapsed,
        setLayoutCollapsed,
        rootPaneNode,
        structureContext: S.context
      };
    }, [layoutCollapsed, rootPaneNode, S.context]),
    children
  });
}

async function resolveIntent(options) {
  const resolvedPaneCache = /* @__PURE__ */new Map();

  const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat(prepareConfig.assignId(unresolvedPane), "-").concat(context.path.join("__"));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane) return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key) resolvedPaneCache.set(key, result);
    return result;
  };

  const resolvePane = prepareConfig.createPaneResolver(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: _objectSpread(_objectSpread({}, lodash.omit(options.params, ["id"])), {}, {
      type: options.params.type
    }),
    payload: options.payload
  }]];

  async function traverse(_ref2) {
    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref2;

    var _a;

    if (!unresolvedPane) return [];

    const {
      id: targetId,
      type: schemaTypeName
    } = params,
          otherParams = _objectWithoutProperties(params, _excluded);

    const context = {
      id: currentId,
      splitIndex: 0,
      parent,
      path,
      index: flatIndex,
      params: {},
      payload: void 0,
      structureContext
    };
    const resolvedPane = await resolvePane(unresolvedPane, context, flatIndex).pipe(operators.first()).toPromise();

    if (resolvedPane.type === "document" && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map(i => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }

    if (((_a = resolvedPane.canHandleIntent) == null ? void 0 : _a.call(resolvedPane, intent, params, {
      pane: resolvedPane,
      index: flatIndex
    })) || resolvedPane.type === "documentList" && resolvedPane.schemaTypeName === schemaTypeName && resolvedPane.options.filter === "_type == $type") {
      return [{
        panes: [...path.map(id => [{
          id
        }]), [{
          id: params.id,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }

    if (resolvedPane.type === "list" && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === "divider") return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === "function" ? prepareConfig.memoBind(resolvedPane, "child") : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }

    return [];
  }

  const matchingPanes = await traverse({
    currentId: "root",
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];

  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }

  return fallbackEditorPanes;
}

function Redirect(_ref3) {
  let {
    panes
  } = _ref3;
  const {
    navigate
  } = prepareConfig.useRouter();
  React.useEffect(() => {
    navigate({
      panes
    }, {
      replace: true
    });
  }, [navigate, panes]);
  return /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
    height: "fill",
    children: /* @__PURE__ */jsxRuntime.jsx(prepareConfig.Delay, {
      ms: 300,
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: [/* @__PURE__ */jsxRuntime.jsx(ui.Spinner, {
          muted: true
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          marginTop: 3,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            muted: true,
            size: 1,
            children: "Redirecting\u2026"
          })
        })]
      })
    })
  });
}

async function ensureDocumentIdAndType(documentStore, id, type) {
  if (id && type) return {
    id,
    type
  };
  if (!id && type) return {
    id: uuid.uuid(),
    type
  };

  if (id && !type) {
    const resolvedType = await documentStore.resolveTypeForDocument(id).pipe(operators.first()).toPromise();
    return {
      id,
      type: resolvedType
    };
  }

  throw new prepareConfig.PaneResolutionError({
    message: "Neither document `id` or `type` was provided when trying to resolve intent."
  });
}

function IntentResolver(_ref4) {
  let {
    intent,
    params: paramsProp = {},
    payload: payloadProp
  } = _ref4;
  const {
    rootPaneNode,
    structureContext
  } = prepareConfig.useDeskTool();
  const documentStore = prepareConfig.useDocumentStore();
  const params = prepareConfig.useUnique(paramsProp);
  const payload = prepareConfig.useUnique(payloadProp);
  const [nextRouterPanes, setNextRouterPanes] = React.useState(null);
  const [error, setError] = React.useState(null);
  const idParam = typeof params.id === "string" ? params.id : void 0;
  const typeParam = typeof params.type === "string" ? params.type : void 0;
  React.useEffect(() => {
    const cancelledRef = {
      current: false
    };

    async function getNextRouterPanes() {
      const {
        id,
        type
      } = await ensureDocumentIdAndType(documentStore, idParam, typeParam);
      return resolveIntent({
        intent,
        params: _objectSpread(_objectSpread({}, params), {}, {
          id,
          type
        }),
        payload,
        rootPaneNode,
        structureContext
      });
    }

    getNextRouterPanes().then(result => {
      if (!cancelledRef.current) {
        setNextRouterPanes(result);
      }
    }).catch(setError);
    return () => {
      cancelledRef.current = true;
    };
  }, [documentStore, idParam, intent, params, payload, rootPaneNode, structureContext, typeParam]);
  if (error) throw error;
  if (nextRouterPanes) return /* @__PURE__ */jsxRuntime.jsx(Redirect, {
    panes: nextRouterPanes
  });
  return /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
    height: "fill",
    children: /* @__PURE__ */jsxRuntime.jsx(prepareConfig.Delay, {
      ms: 300,
      children: /* @__PURE__ */jsxRuntime.jsxs(ui.Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: [/* @__PURE__ */jsxRuntime.jsx(ui.Spinner, {
          muted: true
        }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
          marginTop: 3,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
            align: "center",
            muted: true,
            size: 1,
            children: "Loading\u2026"
          })
        })]
      })
    })
  });
}

const EMPTY_RECORD = {};

function DeskToolBoundary(_ref5) {
  let {
    tool: {
      options
    }
  } = _ref5;
  const {
    unstable_sources: sources
  } = prepareConfig.useWorkspace();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  const {
    state: routerState
  } = prepareConfig.useRouter();
  const intent = React.useMemo(() => {
    const intentName = typeof routerState.intent === "string" ? routerState.intent : void 0;
    const params = prepareConfig.isRecord(routerState.params) ? routerState.params : EMPTY_RECORD;
    const payload = routerState.payload;
    return intentName ? {
      intent: intentName,
      params,
      payload
    } : void 0;
  }, [routerState]);
  React.useEffect(() => {
    desk.setActivePanes([]);
    return () => desk.setActivePanes([]);
  }, []);
  const [{
    error
  }, setError] = React.useState({
    error: null
  });
  if (error) return /* @__PURE__ */jsxRuntime.jsx(prepareConfig.StructureError, {
    error
  });
  return /* @__PURE__ */jsxRuntime.jsx(ui.ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsxRuntime.jsx(prepareConfig.SourceProvider, {
      name: source || firstSource.name,
      children: /* @__PURE__ */jsxRuntime.jsx(DeskToolProvider, {
        defaultDocumentNode,
        structure,
        children: intent ? /* @__PURE__ */jsxRuntime.jsx(IntentResolver, _objectSpread({}, intent)) : /* @__PURE__ */jsxRuntime.jsx(prepareConfig.DeskTool, {
          onPaneChange: desk.setActivePanes
        })
      })
    })
  });
}

exports["default"] = DeskToolBoundary;
//# sourceMappingURL=_index-7424203d.cjs.map
