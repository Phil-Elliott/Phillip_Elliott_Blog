'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

require('react-rx');

require('rxjs');

require('rxjs/operators');

require('shallow-equals');

var lodash = require('lodash');

require('react');

var prepareConfig = require('./_prepareConfig-2f1df9bf.cjs');

class ComponentBuilder {
  constructor(spec) {
    this.spec = _objectSpread({
      options: {}
    }, spec ? spec : {});
  }

  id(id) {
    return this.clone({
      id
    });
  }

  getId() {
    return this.spec.id;
  }

  title(title) {
    return this.clone({
      title,
      id: this.spec.id || lodash.camelCase(title)
    });
  }

  getTitle() {
    return this.spec.title;
  }

  child(child) {
    return this.clone({
      child
    });
  }

  getChild() {
    return this.spec.child;
  }

  component(component) {
    return this.clone({
      component
    });
  }

  getComponent() {
    return this.spec.component;
  }

  options(options) {
    return this.clone({
      options
    });
  }

  getOptions() {
    return this.spec.options || {};
  }

  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }

  getMenuItems() {
    return this.spec.menuItems;
  }

  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }

  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }

  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child,
      options: componentOptions,
      component
    } = this.spec;

    if (!id) {
      throw new prepareConfig.SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.ID_REQUIRED);
    }

    if (!component) {
      throw new prepareConfig.SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.ID_REQUIRED);
    }

    return {
      id: prepareConfig.validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map((item, i) => prepareConfig.maybeSerializeMenuItem(item, i, options.path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => prepareConfig.maybeSerializeMenuItemGroup(item, i, options.path))
    };
  }

  clone(withSpec) {
    const builder = new ComponentBuilder();
    builder.spec = _objectSpread(_objectSpread({}, this.spec), withSpec || {});
    return builder;
  }

}

const getArgType = thing => {
  if (thing instanceof ListBuilder) {
    return "ListBuilder";
  }

  if (isPromise(thing)) {
    return "Promise";
  }

  return Array.isArray(thing) ? "array" : typeof thing;
};

const isListItem = item => {
  return item.type === "listItem";
};

const defaultCanHandleIntent = (intentName, params, context) => {
  const pane = context.pane;
  const items = pane.items || [];
  return items.filter(isDocumentListItem).some(item => item.schemaType.name === params.type && item._id === params.id) || prepareConfig.shallowIntentChecker(intentName, params, context);
};

const resolveChildForItem = (itemId, options) => {
  const parentItem = options.parent;
  const items = parentItem.items.filter(isListItem);
  const target = (items.find(item => item.id === itemId) || {
    child: void 0
  }).child;

  if (!target || typeof target !== "function") {
    return target;
  }

  return typeof target === "function" ? target(itemId, options) : target;
};

function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder) {
    return item.serialize({
      path,
      index
    });
  }

  const listItem = item;

  if (listItem && listItem.type === "divider") {
    return item;
  }

  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem);
    const helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new prepareConfig.SerializeError("List items must be of type \"listItem\", got \"".concat(gotWhat, "\"").concat(helpText), path, index).withHelpUrl(prepareConfig.HELP_URL.INVALID_LIST_ITEM);
  }

  return item;
}

function isPromise(thing) {
  return prepareConfig.isRecord(thing) && typeof thing.then === "function";
}

class ListBuilder extends prepareConfig.GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }

  items(items) {
    return this.clone({
      items
    });
  }

  getItems() {
    return this.spec.items;
  }

  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const id = this.spec.id;

    if (typeof id !== "string" || !id) {
      throw new prepareConfig.SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.ID_REQUIRED);
    }

    const items = typeof this.spec.items === "undefined" ? [] : this.spec.items;

    if (!Array.isArray(items)) {
      throw new prepareConfig.SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    }

    const path = (options.path || []).concat(id);
    const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
    const dupes = serializedItems.filter((val, i) => lodash.find(serializedItems, {
      id: val.id
    }, i + 1));

    if (dupes.length > 0) {
      const dupeIds = dupes.map(item => item.id).slice(0, 5);
      const dupeDesc = dupes.length > 5 ? "".concat(dupeIds.join(", "), "...") : dupeIds.join(", ");
      throw new prepareConfig.SerializeError("List items with same ID found (".concat(dupeDesc, ")"), options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }

    return _objectSpread(_objectSpread({}, super.serialize(options)), {}, {
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    });
  }

  clone(withSpec) {
    const builder = new ListBuilder(this._context);
    builder.spec = _objectSpread(_objectSpread({}, this.spec), withSpec || {});
    return builder;
  }

}

class ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }

  id(id) {
    return this.clone({
      id
    });
  }

  getId() {
    return this.spec.id;
  }

  title(title) {
    return this.clone({
      title,
      id: this.spec.id || lodash.camelCase(title)
    });
  }

  getTitle() {
    return this.spec.title;
  }

  icon(icon) {
    return this.clone({
      icon
    });
  }

  showIcon() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return this.clone({
      displayOptions: _objectSpread(_objectSpread({}, this.spec.displayOptions || {}), {}, {
        showIcon: enabled
      })
    });
  }

  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }

  getIcon() {
    return this.spec.icon;
  }

  child(child) {
    return this.clone({
      child
    });
  }

  getChild() {
    return this.spec.child;
  }

  schemaType(schemaType) {
    return this.clone({
      schemaType
    });
  }

  getSchemaType() {
    const schemaType = this.spec.schemaType;

    if (typeof schemaType === "string") {
      return this._context.schema.get(schemaType);
    }

    return this.spec.schemaType;
  }

  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      id,
      title,
      child
    } = this.spec;

    if (typeof id !== "string" || !id) {
      throw new prepareConfig.SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.ID_REQUIRED);
    }

    if (!options.titleIsOptional && (typeof title !== "string" || !title)) {
      throw new prepareConfig.SerializeError("`title` is required for list items", options.path, id).withHelpUrl(prepareConfig.HELP_URL.TITLE_REQUIRED);
    }

    let schemaType = this.spec.schemaType;

    if (typeof schemaType === "string") {
      const type = this._context.schema.get(schemaType);

      if (!type) {
        throw new prepareConfig.SerializeError("Could not find type \"".concat(schemaType, "\" in schema"), options.path, id).withHelpUrl(prepareConfig.HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      }

      schemaType = type;
    }

    const serializeOptions = {
      path: options.path.concat(id),
      hint: "child"
    };
    let listChild = child instanceof ComponentBuilder || child instanceof prepareConfig.DocumentListBuilder || child instanceof prepareConfig.DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;

    if (typeof listChild === "function") {
      const originalChild = listChild;

      listChild = (itemId, childOptions) => {
        return originalChild(itemId, _objectSpread(_objectSpread({}, childOptions), {}, {
          serializeOptions
        }));
      };
    }

    return _objectSpread(_objectSpread({}, this.spec), {}, {
      id: prepareConfig.validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    });
  }

  clone(withSpec) {
    const builder = new ListItemBuilder(this._context);
    builder.spec = _objectSpread(_objectSpread({}, this.spec), withSpec || {});
    return builder;
  }

}

const createDefaultChildResolver = (context, spec) => documentId => {
  const schemaType = spec.schemaType && (typeof spec.schemaType === "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId
  }) : new prepareConfig.DocumentBuilder(context).id("documentEditor").documentId(documentId);
};

class DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec);
    this._context = _context;
    this.spec = spec ? spec : {};
  }

  serialize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const spec = super.serialize(_objectSpread(_objectSpread({}, options), {}, {
      titleIsOptional: true
    }));

    if (!spec.schemaType) {
      throw new prepareConfig.SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(prepareConfig.HELP_URL.SCHEMA_TYPE_REQUIRED);
    }

    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return _objectSpread(_objectSpread({}, spec), {}, {
      child,
      schemaType: spec.schemaType,
      _id: spec.id
    });
  }

  clone(withSpec) {
    const builder = new DocumentListItemBuilder(this._context);
    builder.spec = _objectSpread(_objectSpread({}, this.spec), withSpec || {});
    return builder;
  }

}

function isDocumentListItem(item) {
  return prepareConfig.isRecord(item) && typeof item.schemaType !== "undefined" && typeof item._id === "string";
}

class DocumentTypeListBuilder extends prepareConfig.DocumentListBuilder {
  constructor(_context, spec) {
    super(_context);
    this._context = _context;
    this.spec = spec ? spec : {};
  }

  child(child) {
    return this.cloneWithoutDefaultIntentHandler({
      child
    });
  }

  clone(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new DocumentTypeListBuilder(this._context);
    builder.spec = _objectSpread(_objectSpread(_objectSpread({}, this.spec), parent.getSpec()), withSpec || {});
    return builder;
  }

  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new DocumentTypeListBuilder(this._context);
    const canHandleIntent = this.spec.canHandleIntent;
    const shouldOverride = canHandleIntent && canHandleIntent.identity === prepareConfig.DEFAULT_INTENT_HANDLER;
    const override = shouldOverride ? {
      canHandleIntent: void 0
    } : {};
    builder.spec = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, parent.getSpec()), this.spec), withSpec || {}), override);
    return builder;
  }

}

exports.ComponentBuilder = ComponentBuilder;
exports.DocumentListItemBuilder = DocumentListItemBuilder;
exports.DocumentTypeListBuilder = DocumentTypeListBuilder;
exports.ListBuilder = ListBuilder;
exports.ListItemBuilder = ListItemBuilder;
exports.isDocumentListItem = isDocumentListItem;
//# sourceMappingURL=_DocumentTypeList-03e0e0a7.cjs.map
