"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDocumentStore = createDocumentStore;

var _studioClient = require("../../studioClient");

var _util = require("../../util");

var _checkoutPair = require("./document-pair/checkoutPair");

var _consistencyStatus = require("./document-pair/consistencyStatus");

var _documentEvents = require("./document-pair/documentEvents");

var _editOperations = require("./document-pair/editOperations");

var _editState = require("./document-pair/editState");

var _operationEvents = require("./document-pair/operationEvents");

var _validation = require("./document-pair/validation");

var _listenQuery = require("./listenQuery");

var _resolveTypeForDocument = require("./resolveTypeForDocument");

var _initialValue = require("./initialValue");

function getIdPairFromPublished(publishedId) {
  if ((0, _util.isDraftId)(publishedId)) {
    throw new Error('editOpsOf does not expect a draft id.');
  }

  return {
    publishedId,
    draftId: (0, _util.getDraftId)(publishedId)
  };
}

function createDocumentStore(_ref) {
  let {
    getClient,
    documentPreviewStore,
    historyStore,
    initialValueTemplates,
    schema
  } = _ref;
  // Note that we're both passing a shared `client` here which is used by the
  // internal operations, and a `getClient` method that we expose to user-land
  // for things like validations
  const client = getClient(_studioClient.DEFAULT_STUDIO_CLIENT_OPTIONS);
  const ctx = {
    client,
    getClient,
    documentPreviewStore,
    historyStore,
    schema
  };
  const caches = {
    pair: {
      editOperations: new Map(),
      editState: new Map()
    }
  };
  const operationEvents = (0, _operationEvents.getOperationEvents)(ctx);
  return {
    // Public API
    checkoutPair(idPair) {
      return (0, _checkoutPair.checkoutPair)(client, idPair);
    },

    initialValue(opts, context) {
      return (0, _initialValue.getInitialValueStream)(schema, initialValueTemplates, documentPreviewStore, opts, context);
    },

    listenQuery(query, params, options) {
      return (0, _listenQuery.listenQuery)(client, query, params, options);
    },

    resolveTypeForDocument(id, specifiedType) {
      return (0, _resolveTypeForDocument.resolveTypeForDocument)(client, id, specifiedType);
    },

    pair: {
      consistencyStatus(publishedId, type) {
        return (0, _consistencyStatus.consistencyStatus)(ctx.client, getIdPairFromPublished(publishedId), type);
      },

      documentEvents(publishedId, type) {
        return (0, _documentEvents.documentEvents)(ctx.client, getIdPairFromPublished(publishedId), type);
      },

      editOperations(publishedId, type) {
        const cache = caches.pair.editOperations;
        const key = "".concat(publishedId, ":").concat(type);
        const cached = cache.get(key);

        if (cached) {
          return cached;
        }

        const ops = (0, _editOperations.editOperations)(ctx, getIdPairFromPublished(publishedId), type);
        cache.set(key, ops);
        return ops;
      },

      editState(publishedId, type) {
        const cache = caches.pair.editState;
        const key = "".concat(publishedId, ":").concat(type);
        const cached = cache.get(key);

        if (cached) {
          return cached;
        }

        const state = (0, _editState.editState)(ctx, getIdPairFromPublished(publishedId), type);
        cache.set(key, state);
        return state;
      },

      operationEvents(publishedId, type) {
        return operationEvents(getIdPairFromPublished(publishedId), type);
      },

      validation(publishedId, type) {
        return (0, _validation.validation)(ctx, getIdPairFromPublished(publishedId), type);
      }

    }
  };
}