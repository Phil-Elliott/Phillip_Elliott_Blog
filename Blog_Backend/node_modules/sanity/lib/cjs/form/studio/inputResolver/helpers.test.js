"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _types = require("@sanity/types");

var _schema = require("../../../schema");

var _internal = require("@sanity/schema/_internal");

var _helpers = require("./helpers");

/* eslint max-nested-callbacks: */
describe('inputResolver/helpers', () => {
  const {
    onlyIndentationObject,
    noIndentationObject
  } = setupTest();
  describe('getFieldLevel', () => {
    const GREATER_THAN_ZERO = 5;
    describe('types without indentation', () => {
      noIndentationObject.fields.forEach(field => {
        it("".concat(field.type.description, " (").concat(field.name, ")"), () => {
          const baseLevel = (0, _helpers.getFieldLevel)(field.type, GREATER_THAN_ZERO);
          expect(baseLevel).toEqual(0);
        });
      });
    });
    describe('types with indentation', () => {
      onlyIndentationObject.fields.forEach(field => {
        it("".concat(field.type.description, " (").concat(field.name, ")"), () => {
          const baseLevel = (0, _helpers.getFieldLevel)(field.type, GREATER_THAN_ZERO);
          expect(baseLevel).toEqual(GREATER_THAN_ZERO);
        });
      });
    });
  });
});

function setupTest() {
  const noIndentationFields = [(0, _types.defineField)({
    type: 'array',
    name: 'array',
    description: 'plain array',
    of: [{
      type: 'noIndentationFields'
    }]
  }), (0, _types.defineField)({
    type: 'array',
    name: 'arrayTagList',
    description: 'array with tag-list',
    of: [{
      type: 'string'
    }],
    options: {
      list: ['1'],
      layout: 'tags'
    }
  }), (0, _types.defineField)({
    type: 'file',
    name: 'file',
    description: 'file without additional fields'
  }), (0, _types.defineField)({
    type: 'image',
    name: 'image',
    description: 'image without additional fields'
  }), (0, _types.defineField)({
    type: 'reference',
    name: 'reference',
    description: 'image without additional fields',
    to: [{
      type: 'noIndentationFields'
    }]
  }), (0, _types.defineField)({
    type: 'slug',
    name: 'slug',
    description: 'any slug'
  })];
  const onlyIndentationFields = [(0, _types.defineField)({
    type: 'string',
    name: 'string',
    description: 'string without list'
  }), (0, _types.defineField)({
    type: 'string',
    name: 'stringEmptyList',
    description: 'string with empty list',
    options: {
      list: []
    }
  }), (0, _types.defineField)({
    type: 'string',
    name: 'stringList',
    description: 'string with list',
    options: {
      list: ['1']
    }
  }), (0, _types.defineField)({
    type: 'number',
    name: 'number',
    description: 'number without list'
  }), (0, _types.defineField)({
    type: 'number',
    name: 'numberEmptyList',
    description: 'number with empty list',
    options: {
      list: []
    }
  }), (0, _types.defineField)({
    type: 'number',
    name: 'numberList',
    description: 'number with list',
    options: {
      list: [1]
    }
  }), (0, _types.defineField)({
    type: 'object',
    name: 'objectVisibleFields',
    description: 'object with visible fields',
    fields: [(0, _types.defineField)({
      type: 'string',
      name: 'string'
    })]
  }), (0, _types.defineField)({
    type: 'file',
    name: 'fileVisibleFields',
    description: 'file with visible fields',
    fields: [(0, _types.defineField)({
      type: 'string',
      name: 'string'
    })]
  }), (0, _types.defineField)({
    type: 'image',
    name: 'imageVisibleFields',
    description: 'image with visible fields',
    fields: [(0, _types.defineField)({
      type: 'string',
      name: 'string'
    })]
  }), (0, _types.defineField)({
    type: 'array',
    name: 'arrayList',
    description: 'array with list (and not tag layout)',
    of: [{
      type: 'string'
    }],
    options: {
      list: ['1']
    }
  })];
  const aliasTypes = [...noIndentationFields, ...onlyIndentationFields].map(field => (0, _types.defineType)({ ...field,
    name: "".concat(field.name, "-alias")
  }));

  function aliasTypeClone(field) {
    const clone = { ...field
    };
    delete clone.of;
    delete clone.to;
    delete clone.fields;
    return { ...clone,
      name: "".concat(field.name, "Alias"),
      type: "".concat(field.name, "-alias")
    };
  }

  const schemaDef = {
    name: 'test',
    types: [...aliasTypes, (0, _types.defineType)({
      name: 'noIndentationFields',
      type: 'object',
      fields: [...noIndentationFields, ...noIndentationFields.map(aliasTypeClone)]
    }), (0, _types.defineType)({
      name: 'onlyIndentationFields',
      type: 'object',
      fields: [...onlyIndentationFields, ...onlyIndentationFields.map(aliasTypeClone)]
    })]
  };
  const validated = (0, _internal.validateSchema)(schemaDef.types).getTypes();
  const validation = (0, _internal.groupProblems)(validated);
  const errors = validation.map(group => group.problems.filter(_ref => {
    let {
      severity
    } = _ref;
    return severity === 'error';
  })).filter(problems => problems.length);

  if (errors.length) {
    throw new Error("Test has incorrectly configured test data: ".concat(JSON.stringify(errors, null, 2)));
  }

  const testSchema = (0, _schema.createSchema)(schemaDef);
  const noIndentationObject = testSchema.get('noIndentationFields');
  const onlyIndentationObject = testSchema.get('onlyIndentationFields');
  return {
    noIndentationObject,
    onlyIndentationObject
  };
}