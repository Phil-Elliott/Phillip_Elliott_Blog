function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import userEvent from '@testing-library/user-event';
import React from 'react';
import { renderStringInput } from '../../../test/form/renderStringInput';
import { StringInput } from './StringInput';
describe('StringInput', () => {
  it('renders input value', async () => {
    const {
      result
    } = await renderStringInput({
      render: inputProps => /*#__PURE__*/React.createElement(StringInput, _extends({}, inputProps, {
        elementProps: { ...inputProps.elementProps,
          value: 'test'
        },
        value: "test"
      })),
      fieldDefinition: {
        type: 'string',
        name: 'string',
        title: 'String'
      }
    });
    const input = result.container.querySelector('input');
    expect(input === null || input === void 0 ? void 0 : input.value).toBe('test');
  });
  it('emits onFocus', async () => {
    const {
      onFocus,
      result
    } = await renderStringInput({
      render: inputProps => /*#__PURE__*/React.createElement(StringInput, _extends({}, inputProps, {
        value: "test",
        elementProps: { ...inputProps.elementProps,
          value: 'test'
        }
      })),
      fieldDefinition: {
        type: 'string',
        name: 'string',
        title: 'String'
      }
    });
    const input = result.container.querySelector('input');
    input === null || input === void 0 ? void 0 : input.focus();
    expect(onFocus.mock.calls).toHaveLength(1);
  });
  it('emits `set` patch', async () => {
    const {
      onNativeChange,
      result
    } = await renderStringInput({
      render: inputProps => /*#__PURE__*/React.createElement(StringInput, _extends({}, inputProps, {
        value: "tes",
        elementProps: { ...inputProps.elementProps,
          value: 'tes'
        }
      })),
      fieldDefinition: {
        type: 'string',
        name: 'string',
        title: 'String'
      }
    });
    const input = result.container.querySelector('input');
    userEvent.type(input, 't');
    expect(onNativeChange).toHaveBeenCalledTimes(1);
  });
  it('emits `unset` patch', async () => {
    const {
      onNativeChange,
      result
    } = await renderStringInput({
      render: inputProps => /*#__PURE__*/React.createElement(StringInput, _extends({}, inputProps, {
        value: "t",
        elementProps: { ...inputProps.elementProps,
          value: 't'
        }
      })),
      fieldDefinition: {
        type: 'string',
        name: 'string',
        title: 'String'
      }
    });
    const input = result.container.querySelector('input');
    expect(input.value).toBe('t');
    userEvent.click(input);
    userEvent.keyboard('[Backspace]');
    expect(onNativeChange).toHaveBeenCalledTimes(1);
  });
});