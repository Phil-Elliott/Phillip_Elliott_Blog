import { DEFAULT_STUDIO_CLIENT_OPTIONS } from '../../studioClient';
import { getDraftId, isDraftId } from '../../util';
import { checkoutPair } from './document-pair/checkoutPair';
import { consistencyStatus } from './document-pair/consistencyStatus';
import { documentEvents } from './document-pair/documentEvents';
import { editOperations } from './document-pair/editOperations';
import { editState } from './document-pair/editState';
import { getOperationEvents } from './document-pair/operationEvents';
import { validation } from './document-pair/validation';
import { listenQuery } from './listenQuery';
import { resolveTypeForDocument } from './resolveTypeForDocument';
import { getInitialValueStream } from './initialValue';

function getIdPairFromPublished(publishedId) {
  if (isDraftId(publishedId)) {
    throw new Error('editOpsOf does not expect a draft id.');
  }

  return {
    publishedId,
    draftId: getDraftId(publishedId)
  };
}

export function createDocumentStore(_ref) {
  let {
    getClient,
    documentPreviewStore,
    historyStore,
    initialValueTemplates,
    schema
  } = _ref;
  // Note that we're both passing a shared `client` here which is used by the
  // internal operations, and a `getClient` method that we expose to user-land
  // for things like validations
  const client = getClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const ctx = {
    client,
    getClient,
    documentPreviewStore,
    historyStore,
    schema
  };
  const caches = {
    pair: {
      editOperations: new Map(),
      editState: new Map()
    }
  };
  const operationEvents = getOperationEvents(ctx);
  return {
    // Public API
    checkoutPair(idPair) {
      return checkoutPair(client, idPair);
    },

    initialValue(opts, context) {
      return getInitialValueStream(schema, initialValueTemplates, documentPreviewStore, opts, context);
    },

    listenQuery(query, params, options) {
      return listenQuery(client, query, params, options);
    },

    resolveTypeForDocument(id, specifiedType) {
      return resolveTypeForDocument(client, id, specifiedType);
    },

    pair: {
      consistencyStatus(publishedId, type) {
        return consistencyStatus(ctx.client, getIdPairFromPublished(publishedId), type);
      },

      documentEvents(publishedId, type) {
        return documentEvents(ctx.client, getIdPairFromPublished(publishedId), type);
      },

      editOperations(publishedId, type) {
        const cache = caches.pair.editOperations;
        const key = "".concat(publishedId, ":").concat(type);
        const cached = cache.get(key);

        if (cached) {
          return cached;
        }

        const ops = editOperations(ctx, getIdPairFromPublished(publishedId), type);
        cache.set(key, ops);
        return ops;
      },

      editState(publishedId, type) {
        const cache = caches.pair.editState;
        const key = "".concat(publishedId, ":").concat(type);
        const cached = cache.get(key);

        if (cached) {
          return cached;
        }

        const state = editState(ctx, getIdPairFromPublished(publishedId), type);
        cache.set(key, state);
        return state;
      },

      operationEvents(publishedId, type) {
        return operationEvents(getIdPairFromPublished(publishedId), type);
      },

      validation(publishedId, type) {
        return validation(ctx, getIdPairFromPublished(publishedId), type);
      }

    }
  };
}