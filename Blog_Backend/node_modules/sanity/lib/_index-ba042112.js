const _excluded = ["id", "type"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { jsx, jsxs } from 'react/jsx-runtime';
import { useState, useMemo, useEffect } from 'react';
import { Card, Flex, Spinner, Box, Text, ErrorBoundary } from '@sanity/ui';
import '@sanity/icons';
import { omit } from 'lodash';
import { u as useSource, dV as DeskToolContext, dW as createPaneResolver, dX as assignId, dY as memoBind, E as useRouter, dO as Delay, dZ as PaneResolutionError, dE as useDeskTool, aZ as useDocumentStore, dS as useUnique, t as useWorkspace, d_ as StructureError, q as SourceProvider, d$ as DeskTool, cL as isRecord } from './_prepareConfig-56d87958.js';
import 'history';
import 'rxjs';
import { first } from 'rxjs/operators';
import '@sanity/bifur-client';
import 'react-is';
import '@sanity/schema';
import '@sanity/schema/_internal';
import '@sanity/validation';
import 'date-fns';
import 'pluralize-esm';
import 'react-rx';
import '@sanity/image-url';
import '@sanity/types';
import 'shallow-equals';
import '@sanity/mutator';
import 'json-reduce';
import 'rxjs-exhaustmap-with-trailing';
import '@sanity/util/content';
import '@sanity/util/paths';
import 'dataloader';
import 'raf';
import 'groq-js';
import 'rxjs-etc/operators';
import 'mendoza';
import '@sanity/diff';
import '@sanity/color';
import 'react-fast-compare';
import '@sanity/portable-text-editor';
import 'scroll-into-view-if-needed';
import '@reach/auto-id';
import '@sanity/util/legacyDateFormat';
import 'speakingurl';
import { uuid } from '@sanity/uuid';
import 'get-random-values-esm';
import '@sanity/asset-utils';
import 'exif-component';
import 'react-dom';
import { u as useConfigContextFromSource, c as createStructureBuilder } from './_createStructureBuilder-25277a65.js';
import { s as setActivePanes } from './_desk-7a7009af.js';
import '@sanity/generate-help-url';
import 'nanoid';
import '@sanity/client';
import '@juggle/resize-observer';
import 'nano-pubsub';
import 'styled-components';
import 'observable-callback';
import 'debug';
import 'react-refractor';
import 'refractor/lang/bash';
import 'refractor/lang/javascript';
import 'refractor/lang/json';
import 'refractor/lang/jsx';
import 'refractor/lang/typescript';
import 'use-hot-module-reload';
import 'classnames';
import 'use-device-pixel-ratio';
import 'color2k';
import 'react-sortable-hoc';
import '@sanity/block-tools';
import 'diff-match-patch';
import 'date-fns/isValid';
import 'react-focus-lock';
import 'date-fns/formatDistanceToNow';
import 'is-hotkey';
import 'react-copy-to-clipboard';
import 'sanity-diff-patch';
import '@rexxars/react-json-inspector';
import 'hashlru';
import 'framer-motion';
import 'react-props-stream';
import '@sanity/logos';
import '@portabletext/react';
import './_DocumentTypeList-43c73c38.js';
import './_createPlugin-6e6e8fa6.js';

function DeskToolProvider(_ref) {
  let {
    defaultDocumentNode,
    structure: resolveStructure,
    children
  } = _ref;
  const [layoutCollapsed, setLayoutCollapsed] = useState(false);
  const source = useSource();
  const configContext = useConfigContextFromSource(source);
  const S = useMemo(() => {
    return createStructureBuilder({
      defaultDocumentNode,
      source
    });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = useMemo(() => {
    if (resolveStructure) return resolveStructure(S, configContext);
    return S.defaults();
  }, [S, resolveStructure, configContext]);
  return /* @__PURE__ */jsx(DeskToolContext.Provider, {
    value: useMemo(() => {
      return {
        features: {
          backButton: layoutCollapsed,
          reviewChanges: !layoutCollapsed,
          splitPanes: !layoutCollapsed,
          splitViews: !layoutCollapsed
        },
        layoutCollapsed,
        setLayoutCollapsed,
        rootPaneNode,
        structureContext: S.context
      };
    }, [layoutCollapsed, rootPaneNode, S.context]),
    children
  });
}

async function resolveIntent(options) {
  const resolvedPaneCache = /* @__PURE__ */new Map();

  const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(context.path.join("__"));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane) return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key) resolvedPaneCache.set(key, result);
    return result;
  };

  const resolvePane = createPaneResolver(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: _objectSpread(_objectSpread({}, omit(options.params, ["id"])), {}, {
      type: options.params.type
    }),
    payload: options.payload
  }]];

  async function traverse(_ref2) {
    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref2;

    var _a;

    if (!unresolvedPane) return [];

    const {
      id: targetId,
      type: schemaTypeName
    } = params,
          otherParams = _objectWithoutProperties(params, _excluded);

    const context = {
      id: currentId,
      splitIndex: 0,
      parent,
      path,
      index: flatIndex,
      params: {},
      payload: void 0,
      structureContext
    };
    const resolvedPane = await resolvePane(unresolvedPane, context, flatIndex).pipe(first()).toPromise();

    if (resolvedPane.type === "document" && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map(i => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }

    if (((_a = resolvedPane.canHandleIntent) == null ? void 0 : _a.call(resolvedPane, intent, params, {
      pane: resolvedPane,
      index: flatIndex
    })) || resolvedPane.type === "documentList" && resolvedPane.schemaTypeName === schemaTypeName && resolvedPane.options.filter === "_type == $type") {
      return [{
        panes: [...path.map(id => [{
          id
        }]), [{
          id: params.id,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }

    if (resolvedPane.type === "list" && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === "divider") return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === "function" ? memoBind(resolvedPane, "child") : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }

    return [];
  }

  const matchingPanes = await traverse({
    currentId: "root",
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];

  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }

  return fallbackEditorPanes;
}

function Redirect(_ref3) {
  let {
    panes
  } = _ref3;
  const {
    navigate
  } = useRouter();
  useEffect(() => {
    navigate({
      panes
    }, {
      replace: true
    });
  }, [navigate, panes]);
  return /* @__PURE__ */jsx(Card, {
    height: "fill",
    children: /* @__PURE__ */jsx(Delay, {
      ms: 300,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: [/* @__PURE__ */jsx(Spinner, {
          muted: true
        }), /* @__PURE__ */jsx(Box, {
          marginTop: 3,
          children: /* @__PURE__ */jsx(Text, {
            muted: true,
            size: 1,
            children: "Redirecting\u2026"
          })
        })]
      })
    })
  });
}

async function ensureDocumentIdAndType(documentStore, id, type) {
  if (id && type) return {
    id,
    type
  };
  if (!id && type) return {
    id: uuid(),
    type
  };

  if (id && !type) {
    const resolvedType = await documentStore.resolveTypeForDocument(id).pipe(first()).toPromise();
    return {
      id,
      type: resolvedType
    };
  }

  throw new PaneResolutionError({
    message: "Neither document `id` or `type` was provided when trying to resolve intent."
  });
}

function IntentResolver(_ref4) {
  let {
    intent,
    params: paramsProp = {},
    payload: payloadProp
  } = _ref4;
  const {
    rootPaneNode,
    structureContext
  } = useDeskTool();
  const documentStore = useDocumentStore();
  const params = useUnique(paramsProp);
  const payload = useUnique(payloadProp);
  const [nextRouterPanes, setNextRouterPanes] = useState(null);
  const [error, setError] = useState(null);
  const idParam = typeof params.id === "string" ? params.id : void 0;
  const typeParam = typeof params.type === "string" ? params.type : void 0;
  useEffect(() => {
    const cancelledRef = {
      current: false
    };

    async function getNextRouterPanes() {
      const {
        id,
        type
      } = await ensureDocumentIdAndType(documentStore, idParam, typeParam);
      return resolveIntent({
        intent,
        params: _objectSpread(_objectSpread({}, params), {}, {
          id,
          type
        }),
        payload,
        rootPaneNode,
        structureContext
      });
    }

    getNextRouterPanes().then(result => {
      if (!cancelledRef.current) {
        setNextRouterPanes(result);
      }
    }).catch(setError);
    return () => {
      cancelledRef.current = true;
    };
  }, [documentStore, idParam, intent, params, payload, rootPaneNode, structureContext, typeParam]);
  if (error) throw error;
  if (nextRouterPanes) return /* @__PURE__ */jsx(Redirect, {
    panes: nextRouterPanes
  });
  return /* @__PURE__ */jsx(Card, {
    height: "fill",
    children: /* @__PURE__ */jsx(Delay, {
      ms: 300,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: [/* @__PURE__ */jsx(Spinner, {
          muted: true
        }), /* @__PURE__ */jsx(Box, {
          marginTop: 3,
          children: /* @__PURE__ */jsx(Text, {
            align: "center",
            muted: true,
            size: 1,
            children: "Loading\u2026"
          })
        })]
      })
    })
  });
}

const EMPTY_RECORD = {};

function DeskToolBoundary(_ref5) {
  let {
    tool: {
      options
    }
  } = _ref5;
  const {
    unstable_sources: sources
  } = useWorkspace();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  const {
    state: routerState
  } = useRouter();
  const intent = useMemo(() => {
    const intentName = typeof routerState.intent === "string" ? routerState.intent : void 0;
    const params = isRecord(routerState.params) ? routerState.params : EMPTY_RECORD;
    const payload = routerState.payload;
    return intentName ? {
      intent: intentName,
      params,
      payload
    } : void 0;
  }, [routerState]);
  useEffect(() => {
    setActivePanes([]);
    return () => setActivePanes([]);
  }, []);
  const [{
    error
  }, setError] = useState({
    error: null
  });
  if (error) return /* @__PURE__ */jsx(StructureError, {
    error
  });
  return /* @__PURE__ */jsx(ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsx(SourceProvider, {
      name: source || firstSource.name,
      children: /* @__PURE__ */jsx(DeskToolProvider, {
        defaultDocumentNode,
        structure,
        children: intent ? /* @__PURE__ */jsx(IntentResolver, _objectSpread({}, intent)) : /* @__PURE__ */jsx(DeskTool, {
          onPaneChange: setActivePanes
        })
      })
    })
  });
}

export { DeskToolBoundary as default };
//# sourceMappingURL=_index-ba042112.js.map
