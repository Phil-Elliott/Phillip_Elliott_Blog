'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var prepareConfig = require('./_prepareConfig-2f1df9bf.cjs');

require('rxjs');

require('rxjs/operators');

var React = require('react');

require('react/jsx-runtime');

var icons = require('@sanity/icons');

var lodash = require('lodash');

require('@sanity/ui');

require('history');

require('@sanity/bifur-client');

require('react-is');

require('@sanity/schema');

require('@sanity/schema/_internal');

require('@sanity/validation');

require('react-rx');

require('shallow-equals');

require('@sanity/types');

require('@sanity/color');

require('@sanity/image-url');

require('@sanity/util/paths');

require('react-fast-compare');

require('@sanity/util/content');

require('@sanity/portable-text-editor');

require('scroll-into-view-if-needed');

require('@reach/auto-id');

require('@sanity/util/legacyDateFormat');

require('date-fns');

require('speakingurl');

var uuid = require('@sanity/uuid');

require('get-random-values-esm');

require('@sanity/asset-utils');

require('exif-component');

require('react-dom');

require('pluralize-esm');

require('@sanity/mutator');

require('json-reduce');

require('rxjs-exhaustmap-with-trailing');

require('dataloader');

require('raf');

require('groq-js');

require('rxjs-etc/operators');

var createPlugin = require('./_createPlugin-904247f9.cjs');

require('mendoza');

require('@sanity/diff');

require('./_DocumentTypeList-03e0e0a7.cjs');

require('nanoid');

require('@sanity/generate-help-url');

const state = {
  activePanes: []
};

function setActivePanes(panes) {
  state.activePanes = panes;
}

function getIntentState(intent, params, routerState, payload) {
  var _a;

  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || uuid.uuid();
  const isTemplate = intent === "create" && params.template;

  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object") continue;

    if (((_a = pane.canHandleIntent) == null ? void 0 : _a.call(pane, intent, params, {
      pane,
      index: i
    })) || pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? {
        template: params.template
      } : prepareConfig.EMPTY_PARAMS;
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }

  return {
    intent,
    params,
    payload
  };
}

const EMPTY_PARAMS = {};

function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}

function encodePanesSegment(panes) {
  return (panes || []).map(group => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}

function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}

function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}

function toPath(panes) {
  return encodePanesSegment(panes);
}

const router = prepareConfig.route.create("/", [prepareConfig.route.intents("/intent"), prepareConfig.route.create("/edit/:type/:editDocumentId", [prepareConfig.route.create({
  path: "/:params",
  transform: {
    params: {
      toState: legacyEditParamsToState,
      toPath: legacyEditParamsToPath
    }
  }
})]), prepareConfig.route.create({
  path: "/:panes",
  children: [prepareConfig.route.create("/:action", prepareConfig.route.create("/:legacyEditDocumentId"))],
  transform: {
    panes: {
      toState,
      toPath
    }
  }
})]);
const panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;

const isParam = str => /^[a-z0-9]+=[^=]+/i.test(str);

const isPayload = str => /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);

const exclusiveParams = ["view", "since", "rev"];
const isTruthy = Boolean;

function parseChunks(chunks, initial) {
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = _objectSpread(_objectSpread({}, pane.params), {}, {
        [decodeURIComponent(key)]: decodeURIComponent(value)
      });
    } else if (isPayload(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }

    return pane;
  }, _objectSpread(_objectSpread({}, initial), {}, {
    params: EMPTY_PARAMS,
    payload: void 0
  }));
}

function encodeChunks(pane, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : btoa(JSON.stringify(payload));
  const encodedParams = Object.entries(params).filter(entry => {
    var _a;

    const [key, value] = entry;
    if (!value) return false;
    if (paneIsFirstSibling) return true;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key)) return false;
    return true;
  }).map(_ref => {
    let [key, value] = _ref;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}

function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }

  return str.split(";").map(group => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map(segment => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map(sibling => _objectSpread(_objectSpread(_objectSpread({}, firstSibling), sibling), {}, {
      id: sibling.id || firstSibling.id,
      params: _objectSpread(_objectSpread({}, lodash.omit(firstSibling.params, exclusiveParams)), sibling.params),
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter(group => group.length > 0);
}

function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;

  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];

    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }

    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    });
    buffer = buffer.slice(match.length);
  }

  return [chunks];
}

function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}

function tryParseBase64Payload(data) {
  return data ? tryParsePayload(atob(data)) : void 0;
}

const deskTool = createPlugin.createPlugin(options => ({
  name: "@sanity/desk-tool",
  tools: [{
    name: (options == null ? void 0 : options.name) || "desk",
    title: (options == null ? void 0 : options.title) || "Desk",
    icon: (options == null ? void 0 : options.icon) || icons.MasterDetailIcon,
    component: React.lazy(() => Promise.resolve().then(function () {
      return require('./_index-7424203d.cjs');
    })),
    canHandleIntent: (intent, params) => {
      return Boolean(intent === "edit" && params.id || intent === "create" && params.type || intent === "create" && params.template);
    },
    getIntentState,
    options,
    router
  }]
}));
exports.deskTool = deskTool;
exports.setActivePanes = setActivePanes;
//# sourceMappingURL=_desk-c9a7b09d.cjs.map
