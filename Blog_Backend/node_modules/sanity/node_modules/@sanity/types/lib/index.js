function isObject(obj) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
}

function isReference(reference) {
    return isObject(reference) && typeof reference._ref === 'string';
}

function isImage(value) {
    return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith('image-');
}

function isCrossDatasetReference(reference) {
    return (isObject(reference) &&
        typeof reference._ref === 'string' &&
        typeof reference._dataset === 'string' &&
        typeof reference._projectId === 'string');
}

function isSanityDocument(document) {
    return (isObject(document) && typeof document._id === 'string' && typeof document._type === 'string');
}
function isTypedObject(obj) {
    return isObject(obj) && typeof obj._type === 'string';
}
function isKeyedObject(obj) {
    return isObject(obj) && typeof obj._key === 'string';
}

function isValidationErrorMarker(marker) {
    return marker.level === 'error';
}
function isValidationWarningMarker(marker) {
    return marker.level === 'warning';
}
function isValidationInfoMarker(marker) {
    return marker.level === 'info';
}

function isCreateMutation(mutation) {
    return 'create' in mutation;
}
function isCreateIfNotExistsMutation(mutation) {
    return 'createIfNotExists' in mutation;
}
function isCreateOrReplaceMutation(mutation) {
    return 'createOrReplace' in mutation;
}
function isDeleteMutation(mutation) {
    return 'delete' in mutation;
}
function isPatchMutation(mutation) {
    return 'patch' in mutation;
}

const reKeySegment = /_key\s*==\s*['"](.*)['"]/;
const reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment === 'number' || (typeof segment === 'string' && /^\[\d+\]$/.test(segment));
}
function isKeySegment(segment) {
    if (typeof segment === 'string') {
        return reKeySegment.test(segment.trim());
    }
    return typeof segment === 'object' && '_key' in segment;
}
function isIndexTuple(segment) {
    if (typeof segment === 'string' && reIndexTuple.test(segment)) {
        return true;
    }
    if (!Array.isArray(segment) || segment.length !== 2) {
        return false;
    }
    const [from, to] = segment;
    return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '');
}

function isRecord$1(value) {
    return !!value && (typeof value == 'object' || typeof value == 'function');
}
function isBlock(value) {
    return (isRecord$1(value) &&
        typeof value._type === 'string' && // block types can be named, so expect anything here.
        typeof value.style === 'string' &&
        Array.isArray(value.children) &&
        Array.isArray(value.markDefs));
}
function isSpan(value) {
    return (isRecord$1(value) &&
        value._type === 'span' &&
        typeof value.text === 'string' &&
        Array.isArray(value.marks));
}

/**
 * Helper function for defining a Sanity type definition. This function does not do anything on its own;
 * it exists to check that your schema definition is correct, and help autocompletion in your IDE.
 *
 * This function will narrow the schema type down to fields and options based on the provided type-string.
 *
 * Schemas defined using `defineType` should typically be added to the Studio config under `schema.types`.
 * Defined types can be referenced by their `name`. This is referred to as a type-alias.
 *
 * When using type-aliases as `type`, `defineType` cannot know the base-type, so type-safety will be reduced.
 * If you know the base type of the type-alias, provide `defineOptions.aliasFor: <base type name>`.
 * This will enforce that the schema definition conforms with the provided type.
 *
 * By default `defineType` only allows known properties and options.
 * Use `defineOptions.strict: false` to allow unknown properties and options.
 *
 * ### Basic usage
 *
 * ```ts
 * defineType({
 *   type: 'object',
 *   name: 'custom-object',
 *   fields: [ {type: 'string', name: 'title', title: 'Title'}],
 * })
 * ```
 *
 * ### Usage with aliasFor narrowing
 *
 * ```ts
 * defineType({
 *   type: 'custom-object',
 *   name: 'redefined-custom-object',
 *   options: {
 *     columns: 2
 *   }
 * }, {aliasFor: 'object' })
 * ```
 *
 * ### Allow unknown properties
 *
 * ```ts
 * defineType({
 *   type: 'custom-object',
 *   name: 'redefined-custom-object',
 *   allowsUnknownProperties: true
 *   options: {
 *     columns: 2,
 *     allowsUnknownOptions: true
 *   }
 * }, {strict: false})
 * ```
 * ### Maximum safety and best autocompletion
 *
 * Use {@link defineType}, {@link defineField} and {@link defineArrayMember}:
 *
 * ```ts
 *  defineType({
 *    type: 'object',
 *    name: 'custom-object',
 *    fields: [
 *      defineField({
 *        type: 'array',
 *        name: 'arrayField',
 *        title: 'Things',
 *        of: [
 *          defineArrayMember({
 *            type: 'object',
 *            name: 'type-name-in-array',
 *            fields: [defineField({type: 'string', name: 'title', title: 'Title'})],
 *          }),
 *        ],
 *      }),
 *    ],
 *  })
 * ```
 *
 * ## Note on type-safety in the current implementation
 *
 * Type-safety inside array-like properties (schema properties like `fields` and `of`) can only be guaranteed when
 * {@link defineField} and {@link defineArrayMember} are used to wrap each value in the array.
 *
 * For array-values without a function-wrapper, TypeScript will resolve to a union type of all possible properties across
 * all schema types. This result in less precise typing.
 *
 * ### Extending the Sanity Schema types
 *
 * If you want to extend the Sanity Schema types with your own properties or options to make them typesafe,
 * you can use [TypeScript declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).
 *
 * With declaration merging, properties and options will be available in a type-safe manner, and
 * `strict: false` will not be necessary.
 *
 * #### Example: Add option to StringOptions
 *
 * ```ts
 * // string.ts
 *
 * //redeclare the sanity module
 * declare module 'sanity' {
 *
 *   // redeclare Schema; it will be merged with Schema in the sanity module
 *   export namespace Schema {
 *
 *       // redeclare StringOptions; it will be merged with Schema.StringOptions in the sanity module
 *      export interface StringOptions {
 *        myCustomOption?: boolean
 *      }
 *   }
 * }
 *
 * // the option is now part of the StringOptions type, just as if it was declared in the sanity codebase:
 * defineType({
 *   type: 'string',
 *   name: 'my-string',
 *   options: {
 *     myCustomOption: true // this does not give an error anymore
 *   }
 * })
 *
 * ```
 *
 * #### Example: Add a schema definition to "intrinsic-types"
 *
 * ```ts
 * //my-custom-type-definition.ts
 *
 * // create a new schema definition based on object (we remove the ability to assign field, change the type add some options)
 *  export type MagicallyAddedDefinition = Omit<Schema.ObjectDefinition, 'type' | 'fields'> & {
 *    type: 'magically-added-type'
 *    options?: {
 *      sparkles?: boolean
 *    }
 *  }
 *
 * declare module 'sanity' {
 *     // redeclares IntrinsicTypeDefinition and adds a named definition to it
 *     // it is very important that the key is the same as the type in the definition ('magically-added-type')
 *     export interface IntrinsicTypeDefinition {
 *       'magically-added-type': MagicallyAddedDefinition
 *     }
 * }
 *
 * // defineType will now narrow `type: 'magically-added-type'` to `MagicallyAddedDefinition`
 * defineType({
 *   type: 'magically-added-type'
 *   name: 'magic',
 *   options: {
 *     sparkles: true // this is allowed,
 *     //@ts-expect-error this is not allowed in MagicallyAddedDefinition.options
 *     sparks: true
 *   }
 * })
 * ```
 *
 * @param schemaDefinition - should be a valid schema type definition.
 * @param defineOptions - optional param to provide type hints for `schemaDefinition`.
 *
 * @see defineField
 * @see defineArrayMember
 * @see typed
 */
function defineType(schemaDefinition, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
defineOptions) {
    return schemaDefinition;
}
/**
 * Define a field within a document, object, image or file definition `fields` array.
 *
 * This function will narrow the schema type down to fields and options based on the provided
 * type-string.
 *
 * Using `defineField` is optional, but should provide improved autocompletion in your IDE, when building your schema.
 * Field-properties like `validation` and `initialValue`will also be more specific.
 *
 * See {@link defineType} for more examples.
 *
 * @param schemaField - should be a valid field type definition.
 * @param defineOptions - optional param to provide type hints for `schemaField`.
 *
 * @see defineField
 * @see defineArrayMember
 * @see typed
 */
function defineField(schemaField, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
defineOptions) {
    return schemaField;
}
/**
 * Define an array item member type within an array definition `of`-array.
 *
 * This function will narrow the schema type down to fields and options based on the provided
 * `type` string.
 *
 * Using `defineArrayMember` is optional, but should provide improved autocompletion in your IDE, when building your schema.
 * Field properties like `validation` and `initialValue` will also be more specific.
 *
 * See {@link defineType} for example usage.
 *
 * @param arrayOfSchema - should be a valid `array.of` member definition.
 * @param defineOptions - optional param to provide type hints for `arrayOfSchema`.
 *
 * @see defineType
 * @see defineField
 * @see typed
 */
function defineArrayMember(arrayOfSchema, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
defineOptions) {
    return arrayOfSchema;
}
/**
 * `typed` can be used to ensure that an object conforms to an exact interface.
 *
 * It can be useful when working with `defineType` and `defineField` on occasions where a wider type with
 * custom options or properties is required.
 *
 * ## Example  usage
 * ```ts
 *  defineField({
 *    type: 'string',
 *    name: 'nestedField',
 *    options: typed<Schema.StringOptions & {myCustomOption: boolean}>({
 *      layout: 'radio',
 *      // allowed
 *      myCustomOption: true,
 *      //@ts-expect-error unknownProp is not part of AssetFieldOptions & Schema.StringOptions
 *      unknownProp: 'not allowed in typed context',
 *    }),
 *  }),
 * ```
 *
 * @param input - returned directly
 */
function typed(input) {
    return input;
}

function isRecord(value) {
    return !!value && (typeof value == 'object' || typeof value == 'function');
}
/**
 * Returns wether or not the given type is a document type
 * (eg that it was defined as `type: 'document'`)
 *
 * @param type - Schema type to test
 * @returns True if type is a document type, false otherwise
 * @public
 */
function isDocumentSchemaType(type) {
    if (!isObjectSchemaType(type)) {
        return false;
    }
    let current = type;
    while (current) {
        if (current.name === 'document') {
            return true;
        }
        current = current.type;
    }
    return false;
}
function isObjectSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'object';
}
function isArraySchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'array';
}
function isArrayOfObjectsSchemaType(type) {
    return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));
}
function isArrayOfPrimitivesSchemaType(type) {
    return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));
}
function isBooleanSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'boolean';
}
function isStringSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'string';
}
function isNumberSchemaType(type) {
    if (!isRecord(type))
        return false;
    return type.jsonType === 'number';
}
function isPrimitiveSchemaType(type) {
    return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);
}
function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === 'reference' || isReferenceSchemaType(type.type));
}
function isCrossDatasetReferenceSchemaType(type) {
    return (isRecord(type) &&
        (type.name === 'crossDatasetReference' || isCrossDatasetReferenceSchemaType(type.type)));
}
function isTitledListValue(item) {
    return typeof item === 'object' && item !== null && 'title' in item && 'value' in item;
}
function isSpanSchemaType(type) {
    if (!isRecord(type))
        return false;
    // we check for `annotations` and `decorators` instead of `type.name` because
    // schema names can technically change if someone extends the type
    return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
function isBlockSchemaType(type) {
    if (!isRecord(type))
        return false;
    if (!Array.isArray(type.fields))
        return false;
    const [maybeSpanChildren, maybeStyle, maybeList] = type.fields;
    return (isBlockChildrenObjectField(maybeSpanChildren) &&
        isStyleObjectField(maybeStyle) &&
        isListObjectField(maybeList));
}
function isStyleObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'style')
        return false;
    return isRecord(field.type) && field.type.jsonType === 'string';
}
function isListObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'list')
        return false;
    return isRecord(field.type) && field.type.jsonType === 'string';
}
function isBlockChildrenObjectField(field) {
    if (!isRecord(field))
        return false;
    if (field.name !== 'children')
        return false;
    if (!isArraySchemaType(field.type))
        return false;
    // there will always be a span item in `SpanChildrenObjectField`
    return field.type.of.some(isSpanSchemaType);
}

function isCreateSquashedMutation(mutation) {
    return 'createSquashed' in mutation;
}

function isValidationError(node) {
    return node.level === 'error';
}
function isValidationWarning(node) {
    return node.level === 'warning';
}
function isValidationInfo(node) {
    return node.level === 'info';
}

export { defineArrayMember, defineField, defineType, isArrayOfObjectsSchemaType, isArrayOfPrimitivesSchemaType, isArraySchemaType, isBlock, isBlockChildrenObjectField, isBlockSchemaType, isBooleanSchemaType, isCreateIfNotExistsMutation, isCreateMutation, isCreateOrReplaceMutation, isCreateSquashedMutation, isCrossDatasetReference, isCrossDatasetReferenceSchemaType, isDeleteMutation, isDocumentSchemaType, isImage, isIndexSegment, isIndexTuple, isKeySegment, isKeyedObject, isListObjectField, isNumberSchemaType, isObjectSchemaType, isPatchMutation, isPrimitiveSchemaType, isReference, isReferenceSchemaType, isSanityDocument, isSpan, isSpanSchemaType, isStringSchemaType, isStyleObjectField, isTitledListValue, isTypedObject, isValidationError, isValidationErrorMarker, isValidationInfo, isValidationInfoMarker, isValidationWarning, isValidationWarningMarker, typed };
//# sourceMappingURL=index.js.map
