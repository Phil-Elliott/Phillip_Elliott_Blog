{"version":3,"file":"index.js","sources":["../src/helpers.ts","../src/reference/asserters.ts","../src/assets/asserters.ts","../src/crossDatasetReference/asserters.ts","../src/documents/asserters.ts","../src/markers/asserters.ts","../src/mutations/asserters.ts","../src/paths/asserters.ts","../src/portableText/asserters.ts","../src/schema/define.ts","../src/schema/asserters.ts","../src/transactionLog/asserters.ts","../src/validation/asserters.ts"],"sourcesContent":["export function isObject(obj: unknown): obj is Record<string, unknown> {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj)\n}\n","import {isObject} from '../helpers'\nimport type {Reference} from './types'\n\nexport function isReference(reference: unknown): reference is Reference {\n  return isObject(reference) && typeof reference._ref === 'string'\n}\n","import {isObject} from '../helpers'\nimport {isReference} from '../reference'\nimport type {Image} from './types'\n\nexport function isImage(value: unknown): value is Image {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith('image-')\n}\n","import {isObject} from '../helpers'\nimport type {CrossDatasetReference} from './types'\n\nexport function isCrossDatasetReference(reference: unknown): reference is CrossDatasetReference {\n  return (\n    isObject(reference) &&\n    typeof reference._ref === 'string' &&\n    typeof reference._dataset === 'string' &&\n    typeof reference._projectId === 'string'\n  )\n}\n","import {isObject} from '../helpers'\nimport type {KeyedObject, SanityDocument, TypedObject} from './types'\n\nexport function isSanityDocument(document: unknown): document is SanityDocument {\n  return (\n    isObject(document) && typeof document._id === 'string' && typeof document._type === 'string'\n  )\n}\n\nexport function isTypedObject(obj: unknown): obj is TypedObject {\n  return isObject(obj) && typeof obj._type === 'string'\n}\n\nexport function isKeyedObject(obj: unknown): obj is KeyedObject {\n  return isObject(obj) && typeof obj._key === 'string'\n}\n","import type {ValidationMarker} from './types'\n\nexport function isValidationErrorMarker(\n  marker: ValidationMarker\n): marker is ValidationMarker & {level: 'error'} {\n  return marker.level === 'error'\n}\n\nexport function isValidationWarningMarker(\n  marker: ValidationMarker\n): marker is ValidationMarker & {level: 'warning'} {\n  return marker.level === 'warning'\n}\n\nexport function isValidationInfoMarker(\n  marker: ValidationMarker\n): marker is ValidationMarker & {level: 'info'} {\n  return marker.level === 'info'\n}\n","import type {TransactionLogMutation} from '../transactionLog'\nimport type {\n  CreateIfNotExistsMutation,\n  CreateMutation,\n  CreateOrReplaceMutation,\n  DeleteMutation,\n  Mutation,\n  PatchMutation,\n} from './types'\n\nexport function isCreateMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateMutation {\n  return 'create' in mutation\n}\n\nexport function isCreateIfNotExistsMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateIfNotExistsMutation {\n  return 'createIfNotExists' in mutation\n}\n\nexport function isCreateOrReplaceMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateOrReplaceMutation {\n  return 'createOrReplace' in mutation\n}\n\nexport function isDeleteMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is DeleteMutation {\n  return 'delete' in mutation\n}\n\nexport function isPatchMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is PatchMutation {\n  return 'patch' in mutation\n}\n","import type {PathSegment, KeyedSegment, IndexTuple} from './types'\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n","import type {Block, Span} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value == 'object' || typeof value == 'function')\n}\n\nexport function isBlock<T = Span>(value: unknown): value is Block<T> {\n  return (\n    isRecord(value) &&\n    typeof value._type === 'string' && // block types can be named, so expect anything here.\n    typeof value.style === 'string' &&\n    Array.isArray(value.children) &&\n    Array.isArray(value.markDefs)\n  )\n}\n\nexport function isSpan(value: unknown): value is Span {\n  return (\n    isRecord(value) &&\n    value._type === 'span' &&\n    typeof value.text === 'string' &&\n    Array.isArray(value.marks)\n  )\n}\n","import type {Schema} from './types'\nimport type {\n  DefineArrayMemberBase,\n  DefineOptions,\n  DefineSchemaBase,\n  MaybeAllowUnknownProps,\n  NarrowPreview,\n  StrictDefinition,\n  WidenInitialValue,\n  WidenValidation,\n} from './defineTypes'\n\n/**\n * Helper function for defining a Sanity type definition. This function does not do anything on its own;\n * it exists to check that your schema definition is correct, and help autocompletion in your IDE.\n *\n * This function will narrow the schema type down to fields and options based on the provided type-string.\n *\n * Schemas defined using `defineType` should typically be added to the Studio config under `schema.types`.\n * Defined types can be referenced by their `name`. This is referred to as a type-alias.\n *\n * When using type-aliases as `type`, `defineType` cannot know the base-type, so type-safety will be reduced.\n * If you know the base type of the type-alias, provide `defineOptions.aliasFor: <base type name>`.\n * This will enforce that the schema definition conforms with the provided type.\n *\n * By default `defineType` only allows known properties and options.\n * Use `defineOptions.strict: false` to allow unknown properties and options.\n *\n * ### Basic usage\n *\n * ```ts\n * defineType({\n *   type: 'object',\n *   name: 'custom-object',\n *   fields: [ {type: 'string', name: 'title', title: 'Title'}],\n * })\n * ```\n *\n * ### Usage with aliasFor narrowing\n *\n * ```ts\n * defineType({\n *   type: 'custom-object',\n *   name: 'redefined-custom-object',\n *   options: {\n *     columns: 2\n *   }\n * }, {aliasFor: 'object' })\n * ```\n *\n * ### Allow unknown properties\n *\n * ```ts\n * defineType({\n *   type: 'custom-object',\n *   name: 'redefined-custom-object',\n *   allowsUnknownProperties: true\n *   options: {\n *     columns: 2,\n *     allowsUnknownOptions: true\n *   }\n * }, {strict: false})\n * ```\n * ### Maximum safety and best autocompletion\n *\n * Use {@link defineType}, {@link defineField} and {@link defineArrayMember}:\n *\n * ```ts\n *  defineType({\n *    type: 'object',\n *    name: 'custom-object',\n *    fields: [\n *      defineField({\n *        type: 'array',\n *        name: 'arrayField',\n *        title: 'Things',\n *        of: [\n *          defineArrayMember({\n *            type: 'object',\n *            name: 'type-name-in-array',\n *            fields: [defineField({type: 'string', name: 'title', title: 'Title'})],\n *          }),\n *        ],\n *      }),\n *    ],\n *  })\n * ```\n *\n * ## Note on type-safety in the current implementation\n *\n * Type-safety inside array-like properties (schema properties like `fields` and `of`) can only be guaranteed when\n * {@link defineField} and {@link defineArrayMember} are used to wrap each value in the array.\n *\n * For array-values without a function-wrapper, TypeScript will resolve to a union type of all possible properties across\n * all schema types. This result in less precise typing.\n *\n * ### Extending the Sanity Schema types\n *\n * If you want to extend the Sanity Schema types with your own properties or options to make them typesafe,\n * you can use [TypeScript declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).\n *\n * With declaration merging, properties and options will be available in a type-safe manner, and\n * `strict: false` will not be necessary.\n *\n * #### Example: Add option to StringOptions\n *\n * ```ts\n * // string.ts\n *\n * //redeclare the sanity module\n * declare module 'sanity' {\n *\n *   // redeclare Schema; it will be merged with Schema in the sanity module\n *   export namespace Schema {\n *\n *       // redeclare StringOptions; it will be merged with Schema.StringOptions in the sanity module\n *      export interface StringOptions {\n *        myCustomOption?: boolean\n *      }\n *   }\n * }\n *\n * // the option is now part of the StringOptions type, just as if it was declared in the sanity codebase:\n * defineType({\n *   type: 'string',\n *   name: 'my-string',\n *   options: {\n *     myCustomOption: true // this does not give an error anymore\n *   }\n * })\n *\n * ```\n *\n * #### Example: Add a schema definition to \"intrinsic-types\"\n *\n * ```ts\n * //my-custom-type-definition.ts\n *\n * // create a new schema definition based on object (we remove the ability to assign field, change the type add some options)\n *  export type MagicallyAddedDefinition = Omit<Schema.ObjectDefinition, 'type' | 'fields'> & {\n *    type: 'magically-added-type'\n *    options?: {\n *      sparkles?: boolean\n *    }\n *  }\n *\n * declare module 'sanity' {\n *     // redeclares IntrinsicTypeDefinition and adds a named definition to it\n *     // it is very important that the key is the same as the type in the definition ('magically-added-type')\n *     export interface IntrinsicTypeDefinition {\n *       'magically-added-type': MagicallyAddedDefinition\n *     }\n * }\n *\n * // defineType will now narrow `type: 'magically-added-type'` to `MagicallyAddedDefinition`\n * defineType({\n *   type: 'magically-added-type'\n *   name: 'magic',\n *   options: {\n *     sparkles: true // this is allowed,\n *     //@ts-expect-error this is not allowed in MagicallyAddedDefinition.options\n *     sparks: true\n *   }\n * })\n * ```\n *\n * @param schemaDefinition - should be a valid schema type definition.\n * @param defineOptions - optional param to provide type hints for `schemaDefinition`.\n *\n * @see defineField\n * @see defineArrayMember\n * @see typed\n */\nexport function defineType<\n  TType extends string | Schema.Type, // Schema.Type here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends Schema.Type | undefined,\n  TStrict extends StrictDefinition\n>(\n  schemaDefinition: {\n    type: TType\n    name: TName\n  } & DefineSchemaBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict>,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineOptions<TStrict, TAlias>\n): typeof schemaDefinition {\n  return schemaDefinition\n}\n\n/**\n * Define a field within a document, object, image or file definition `fields` array.\n *\n * This function will narrow the schema type down to fields and options based on the provided\n * type-string.\n *\n * Using `defineField` is optional, but should provide improved autocompletion in your IDE, when building your schema.\n * Field-properties like `validation` and `initialValue`will also be more specific.\n *\n * See {@link defineType} for more examples.\n *\n * @param schemaField - should be a valid field type definition.\n * @param defineOptions - optional param to provide type hints for `schemaField`.\n *\n * @see defineField\n * @see defineArrayMember\n * @see typed\n */\nexport function defineField<\n  TType extends string | Schema.Type, // Schema.Type here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends Schema.Type | undefined,\n  TStrict extends StrictDefinition\n>(\n  schemaField: {\n    type: TType\n    name: TName\n  } & DefineSchemaBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict> &\n    Schema.FieldBase,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineOptions<TStrict, TAlias>\n): typeof schemaField & WidenValidation & WidenInitialValue {\n  return schemaField\n}\n\n/**\n * Define an array item member type within an array definition `of`-array.\n *\n * This function will narrow the schema type down to fields and options based on the provided\n * `type` string.\n *\n * Using `defineArrayMember` is optional, but should provide improved autocompletion in your IDE, when building your schema.\n * Field properties like `validation` and `initialValue` will also be more specific.\n *\n * See {@link defineType} for example usage.\n *\n * @param arrayOfSchema - should be a valid `array.of` member definition.\n * @param defineOptions - optional param to provide type hints for `arrayOfSchema`.\n *\n * @see defineType\n * @see defineField\n * @see typed\n */\nexport function defineArrayMember<\n  TType extends string | Schema.Type, // Schema.Type here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends Schema.Type | undefined,\n  TStrict extends StrictDefinition\n>(\n  arrayOfSchema: {\n    type: TType\n    /**\n     * When provided, `name` is used as `_type` for the array item when stored.\n     *\n     * Necessary when an array contains multiple entries with the same `type`, each with\n     * different configuration (title and initialValue for instance).\n     */\n    name?: TName\n  } & DefineArrayMemberBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict>,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineOptions<TStrict, TAlias>\n): typeof arrayOfSchema & WidenValidation & WidenInitialValue {\n  return arrayOfSchema\n}\n\n/**\n * `typed` can be used to ensure that an object conforms to an exact interface.\n *\n * It can be useful when working with `defineType` and `defineField` on occasions where a wider type with\n * custom options or properties is required.\n *\n * ## Example  usage\n * ```ts\n *  defineField({\n *    type: 'string',\n *    name: 'nestedField',\n *    options: typed<Schema.StringOptions & {myCustomOption: boolean}>({\n *      layout: 'radio',\n *      // allowed\n *      myCustomOption: true,\n *      //@ts-expect-error unknownProp is not part of AssetFieldOptions & Schema.StringOptions\n *      unknownProp: 'not allowed in typed context',\n *    }),\n *  }),\n * ```\n *\n * @param input - returned directly\n */\nexport function typed<T>(input: T): T {\n  return input\n}\n","import type {CrossDatasetReferenceSchemaType} from '../crossDatasetReference'\nimport type {\n  BlockSchemaType,\n  ArraySchemaType,\n  ObjectSchemaType,\n  ReferenceSchemaType,\n  SpanSchemaType,\n  TitledListValue,\n  BlockChildrenObjectField,\n  StyleObjectField,\n  ListObjectField,\n  BooleanSchemaType,\n  StringSchemaType,\n  NumberSchemaType,\n  SchemaType,\n} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value == 'object' || typeof value == 'function')\n}\n\n/**\n * Returns wether or not the given type is a document type\n * (eg that it was defined as `type: 'document'`)\n *\n * @param type - Schema type to test\n * @returns True if type is a document type, false otherwise\n * @public\n */\nexport function isDocumentSchemaType(type: unknown): type is ObjectSchemaType {\n  if (!isObjectSchemaType(type)) {\n    return false\n  }\n\n  let current: SchemaType | undefined = type as SchemaType\n  while (current) {\n    if (current.name === 'document') {\n      return true\n    }\n\n    current = current.type\n  }\n  return false\n}\n\nexport function isObjectSchemaType(type: unknown): type is ObjectSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'object'\n}\n\nexport function isArraySchemaType(type: unknown): type is ArraySchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'array'\n}\n\nexport function isArrayOfObjectsSchemaType(\n  type: unknown\n): type is ArraySchemaType<ObjectSchemaType> {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType))\n}\n\nexport function isArrayOfPrimitivesSchemaType(type: unknown): type is ArraySchemaType {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType))\n}\n\nexport function isBooleanSchemaType(type: unknown): type is BooleanSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'boolean'\n}\n\nexport function isStringSchemaType(type: unknown): type is StringSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'string'\n}\n\nexport function isNumberSchemaType(type: unknown): type is NumberSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'number'\n}\n\nexport function isPrimitiveSchemaType(\n  type: unknown\n): type is BooleanSchemaType | StringSchemaType | NumberSchemaType {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type)\n}\n\nexport function isReferenceSchemaType(type: unknown): type is ReferenceSchemaType {\n  return isRecord(type) && (type.name === 'reference' || isReferenceSchemaType(type.type))\n}\n\nexport function isCrossDatasetReferenceSchemaType(\n  type: unknown\n): type is CrossDatasetReferenceSchemaType {\n  return (\n    isRecord(type) &&\n    (type.name === 'crossDatasetReference' || isCrossDatasetReferenceSchemaType(type.type))\n  )\n}\n\nexport function isTitledListValue(item: unknown): item is TitledListValue {\n  return typeof item === 'object' && item !== null && 'title' in item && 'value' in item\n}\n\nexport function isSpanSchemaType(type: unknown): type is SpanSchemaType {\n  if (!isRecord(type)) return false\n  // we check for `annotations` and `decorators` instead of `type.name` because\n  // schema names can technically change if someone extends the type\n  return Array.isArray(type.annotations) && Array.isArray(type.decorators)\n}\n\nexport function isBlockSchemaType(type: unknown): type is BlockSchemaType {\n  if (!isRecord(type)) return false\n  if (!Array.isArray(type.fields)) return false\n\n  const [maybeSpanChildren, maybeStyle, maybeList] = type.fields\n  return (\n    isBlockChildrenObjectField(maybeSpanChildren) &&\n    isStyleObjectField(maybeStyle) &&\n    isListObjectField(maybeList)\n  )\n}\n\nexport function isStyleObjectField(field: unknown): field is StyleObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'style') return false\n  return isRecord(field.type) && field.type.jsonType === 'string'\n}\n\nexport function isListObjectField(field: unknown): field is ListObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'list') return false\n  return isRecord(field.type) && field.type.jsonType === 'string'\n}\n\nexport function isBlockChildrenObjectField(field: unknown): field is BlockChildrenObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'children') return false\n  if (!isArraySchemaType(field.type)) return false\n  // there will always be a span item in `SpanChildrenObjectField`\n  return field.type.of.some(isSpanSchemaType)\n}\n","import type {Mutation} from '../mutations'\nimport type {CreateSquashedMutation, TransactionLogMutation} from './types'\n\nexport function isCreateSquashedMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateSquashedMutation {\n  return 'createSquashed' in mutation\n}\n","import type {NodeValidation} from './types'\n\nexport function isValidationError(node: NodeValidation): node is NodeValidation & {level: 'error'} {\n  return node.level === 'error'\n}\n\nexport function isValidationWarning(\n  node: NodeValidation\n): node is NodeValidation & {level: 'warning'} {\n  return node.level === 'warning'\n}\n\nexport function isValidationInfo(node: NodeValidation): node is NodeValidation & {level: 'info'} {\n  return node.level === 'info'\n}\n"],"names":["isRecord"],"mappings":"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"}