import React from 'react';
import { Subject, defer, of, EMPTY } from 'rxjs';
import { concatMap, share, switchMap, tap } from 'rxjs/operators';
import { randomKey } from '@sanity/util/content';
import { createEditor } from 'slate';
import { debounce, isEqual, throttle } from 'lodash';
import { Slate } from '@sanity/slate-react';
import { compileType } from '../utils/schema';
import { getPortableTextFeatures } from '../utils/getPortableTextFeatures';
import { validateValue } from '../utils/validateValue';
import { debugWithName } from '../utils/debug';
import { getValueOrInitialValue, isEqualToEmptyEditor, toSlateValue } from '../utils/values';
import { KEY_TO_SLATE_ELEMENT, KEY_TO_VALUE_ELEMENT } from '../utils/weakMaps';
import { PortableTextEditorContext } from './hooks/usePortableTextEditor';
import { PortableTextEditorSelectionContext } from './hooks/usePortableTextEditorSelection';
import { PortableTextEditorValueContext } from './hooks/usePortableTextEditorValue';
import { withPlugins } from './plugins';
// Debounce time for flushing local patches (ms since user haven't produced a patch)
// (lower time for tests to speed them up)
export const FLUSH_PATCHES_DEBOUNCE_MS = process.env.NODE_ENV === 'test' ? 50 : 1000;
export const defaultKeyGenerator = () => randomKey(12);
const debug = debugWithName('component:PortableTextEditor');
export class PortableTextEditor extends React.Component {
    constructor(props) {
        super(props);
        this.change$ = new Subject();
        this.pendingPatches = [];
        this.returnedPatches = [];
        this.setEditable = (editable) => {
            this.editable = { ...this.editable, ...editable };
            this.change$.next({ type: 'value', value: this.props.value || undefined });
            this.change$.next({ type: 'ready' });
        };
        this.syncValue = (userCallbackFn) => {
            const val = this.props.value;
            const callbackFn = () => {
                debug('Updating slate instance');
                this.slateInstance.onChange();
                this.change$.next({ type: 'value', value: val });
                if (userCallbackFn) {
                    userCallbackFn();
                }
            };
            if (this.hasPendingLocalPatches.current) {
                debug('Not syncing value (has pending local patches)');
                retrySync(() => this.syncValue(), callbackFn);
                return;
            }
            // If the  editor is empty and there is a new value, just set that value directly.
            if (isEqualToEmptyEditor(this.slateInstance.children, this.portableTextFeatures) &&
                this.props.value) {
                this.slateInstance.children = toSlateValue(val, {
                    portableTextFeatures: this.portableTextFeatures,
                }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance));
                callbackFn();
                return;
            }
            // Test for diffs between our state value and the incoming value.
            const isEqualToValue = !(val || []).some((blk, index) => {
                const compareBlock = toSlateValue([blk], { portableTextFeatures: this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance))[0];
                if (!isEqual(compareBlock, this.slateInstance.children[index])) {
                    return true;
                }
                return false;
            });
            if (isEqualToValue) {
                debug('Not syncing value (value is equal)');
                return;
            }
            // Value is different - validate it.
            debug('Validating');
            const validation = validateValue(val, this.portableTextFeatures, this.keyGenerator);
            if (val && !validation.valid) {
                this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: val,
                });
                this.setState({ invalidValueResolution: validation.resolution });
            }
            // Set the new value
            debug('Replacing changed nodes');
            if (this.props.value) {
                const slateValueFromProps = toSlateValue(val, {
                    portableTextFeatures: this.portableTextFeatures,
                }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance));
                this.slateInstance.children = slateValueFromProps;
            }
            else {
                this.slateInstance.children = [this.slateInstance.createPlaceholderBlock()];
            }
            callbackFn();
        };
        this.flush = () => {
            const { onChange } = this.props;
            const finalPatches = [...this.pendingPatches];
            if (finalPatches.length > 0) {
                debug('Flushing', finalPatches);
                finalPatches.forEach((p) => {
                    this.returnedPatches.push(p);
                });
                onChange({ type: 'mutation', patches: finalPatches });
                this.pendingPatches = [];
            }
        };
        this.flushDebounced = debounce(this.flush, FLUSH_PATCHES_DEBOUNCE_MS, {
            leading: false,
            trailing: true,
        });
        if (!props.type) {
            throw new Error('PortableTextEditor: missing "type" property');
        }
        this.hasPendingLocalPatches = React.createRef();
        this.hasPendingLocalPatches.current = false;
        this.state = {
            invalidValueResolution: null,
            selection: null,
            initialValue: [], // Created in the constructor
        };
        // Test if we have a compiled schema type, if not, conveniently compile it
        this.type = props.type.hasOwnProperty('jsonType') ? props.type : compileType(props.type);
        // Indicate that we are loading
        this.change$.next({ type: 'loading', isLoading: true });
        // Get the block types feature set (lookup table)
        this.portableTextFeatures = getPortableTextFeatures(this.type);
        // Setup keyGenerator (either from props, or default)
        this.keyGenerator = props.keyGenerator || defaultKeyGenerator;
        // Setup processed incoming patches stream
        if (props.incomingPatches$) {
            // Buffer patches until we are no longer producing local patches
            this.incomingPatches$ = props.incomingPatches$
                .pipe(tap(({ patches }) => {
                // Reset hasPendingLocalPatches when local patches are returned
                if (patches.some((p) => p.origin === 'local')) {
                    this.hasPendingLocalPatches.current = false;
                }
            }))
                .pipe(bufferUntil(() => !this.hasPendingLocalPatches.current), concatMap((incoming) => {
                return incoming;
            }), share());
        }
        // Subscribe to editor events and set state for selection and pending patches
        this.changeSubscription = this.change$.subscribe((next) => {
            const { onChange } = this.props;
            switch (next.type) {
                case 'patch':
                    this.pendingPatches.push(next.patch);
                    if (this.props.incomingPatches$) {
                        this.hasPendingLocalPatches.current = true;
                    }
                    this.flushDebounced();
                    onChange(next);
                    break;
                case 'selection':
                    onChange(next);
                    this.setState({ selection: next.selection });
                    break;
                default:
                    onChange(next);
            }
        });
        // Set maxBlocks and readOnly
        this.maxBlocks =
            typeof props.maxBlocks === 'undefined'
                ? undefined
                : parseInt(props.maxBlocks.toString(), 10) || undefined;
        this.readOnly = Boolean(props.readOnly) || false;
        // Validate the incoming value
        if (props.value) {
            const validation = validateValue(props.value, this.portableTextFeatures, this.keyGenerator);
            if (props.value && !validation.valid) {
                this.change$.next({ type: 'loading', isLoading: false });
                this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: props.value,
                });
                this.state = { ...this.state, invalidValueResolution: validation.resolution };
            }
        }
        // Create the slate instance
        this.slateInstance = withPlugins(createEditor(), {
            change$: this.change$,
            incomingPatches$: this.incomingPatches$,
            keyGenerator: this.keyGenerator,
            maxBlocks: this.maxBlocks,
            portableTextFeatures: this.portableTextFeatures,
            readOnly: this.readOnly,
            syncValue: this.syncValue,
        });
        this.state = {
            ...this.state,
            initialValue: toSlateValue(getValueOrInitialValue(props.value, [this.slateInstance.createPlaceholderBlock()]), { portableTextFeatures: this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance)),
        };
        KEY_TO_VALUE_ELEMENT.set(this.slateInstance, {});
        KEY_TO_SLATE_ELEMENT.set(this.slateInstance, {});
    }
    componentWillUnmount() {
        this.flush();
        this.changeSubscription.unsubscribe();
        this.slateInstance.destroy();
    }
    componentDidUpdate(prevProps) {
        // Whenever readOnly toggles, recreate the editor's plugin chain
        if (this.props.readOnly !== prevProps.readOnly) {
            this.readOnly = Boolean(this.props.readOnly);
            this.slateInstance = withPlugins(this.slateInstance, {
                change$: this.change$,
                incomingPatches$: this.incomingPatches$,
                keyGenerator: this.keyGenerator,
                maxBlocks: this.maxBlocks,
                portableTextFeatures: this.portableTextFeatures,
                readOnly: this.readOnly,
                syncValue: this.syncValue,
            });
        }
        // Update the maxBlocks prop
        if (this.props.maxBlocks !== prevProps.maxBlocks) {
            this.maxBlocks =
                typeof this.props.maxBlocks === 'undefined'
                    ? undefined
                    : parseInt(this.props.maxBlocks.toString(), 10) || undefined;
            this.slateInstance.maxBlocks = this.maxBlocks;
        }
        // Sync value from props, but not when we are responding to incoming patches
        // (if this is the case, we sync the value after the incoming patches has been processed - see createWithPatches plugin)
        if (this.props.value !== prevProps.value &&
            (!prevProps.value || this.readOnly || !this.props.incomingPatches$)) {
            this.syncValue();
        }
    }
    render() {
        if (this.state.invalidValueResolution) {
            return this.state.invalidValueResolution.description;
        }
        return (React.createElement(PortableTextEditorContext.Provider, { value: this },
            React.createElement(PortableTextEditorValueContext.Provider, { value: this.props.value },
                React.createElement(PortableTextEditorSelectionContext.Provider, { value: this.state.selection },
                    React.createElement(Slate, { onChange: NOOP, editor: this.slateInstance, value: this.state.initialValue }, this.props.children)))));
    }
}
// Static API methods
PortableTextEditor.activeAnnotations = (editor) => {
    return editor && editor.editable ? editor.editable.activeAnnotations() : [];
};
PortableTextEditor.addAnnotation = (editor, type, value) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.addAnnotation(type, value); };
PortableTextEditor.blur = (editor) => {
    var _a;
    debug('Host blurred');
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.blur();
};
PortableTextEditor.delete = (editor, selection, options) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.delete(selection, options); };
PortableTextEditor.findDOMNode = (editor, element) => {
    var _a;
    // eslint-disable-next-line react/no-find-dom-node
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findDOMNode(element);
};
PortableTextEditor.findByPath = (editor, path) => {
    var _a;
    return ((_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findByPath(path)) || [];
};
PortableTextEditor.focus = (editor) => {
    var _a;
    debug('Host requesting focus');
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focus();
};
PortableTextEditor.focusBlock = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusBlock();
};
PortableTextEditor.focusChild = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusChild();
};
PortableTextEditor.getPortableTextFeatures = (editor) => {
    return editor.portableTextFeatures;
};
PortableTextEditor.getSelection = (editor) => {
    return editor.editable ? editor.editable.getSelection() : null;
};
PortableTextEditor.getValue = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.getValue();
};
PortableTextEditor.hasBlockStyle = (editor, blockStyle) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasBlockStyle(blockStyle);
};
PortableTextEditor.hasListStyle = (editor, listStyle) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasListStyle(listStyle);
};
PortableTextEditor.isCollapsedSelection = (editor) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isCollapsedSelection(); };
PortableTextEditor.isExpandedSelection = (editor) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isExpandedSelection(); };
PortableTextEditor.isMarkActive = (editor, mark) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isMarkActive(mark); };
PortableTextEditor.insertChild = (editor, type, value) => {
    var _a;
    debug(`Host inserting child`);
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertChild(type, value);
};
PortableTextEditor.insertBlock = (editor, type, value) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertBlock(type, value);
};
PortableTextEditor.isVoid = (editor, element) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isVoid(element);
};
PortableTextEditor.isObjectPath = (editor, path) => {
    if (!path || !Array.isArray(path))
        return false;
    const isChildObjectEditPath = path.length > 3 && path[1] === 'children';
    const isBlockObjectEditPath = path.length > 1 && path[1] !== 'children';
    return isBlockObjectEditPath || isChildObjectEditPath;
};
PortableTextEditor.marks = (editor) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.marks();
};
PortableTextEditor.select = (editor, selection) => {
    var _a;
    debug(`Host setting selection`, selection);
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.select(selection);
};
PortableTextEditor.removeAnnotation = (editor, type) => { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.removeAnnotation(type); };
PortableTextEditor.toggleBlockStyle = (editor, blockStyle) => {
    var _a;
    debug(`Host is toggling block style`);
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleBlockStyle(blockStyle);
};
PortableTextEditor.toggleList = (editor, listStyle) => {
    var _a;
    return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleList(listStyle);
};
PortableTextEditor.toggleMark = (editor, mark) => {
    var _a;
    debug(`Host toggling mark`, mark);
    (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleMark(mark);
};
const retrySync = throttle((syncFn, callbackFn) => syncFn(callbackFn), 100);
function bufferUntil(emitWhen) {
    return (source) => defer(() => {
        let buffer = []; // custom buffer
        return source.pipe(tap((v) => buffer.push(v)), // add values to buffer
        switchMap(() => (emitWhen(buffer) ? of(buffer) : EMPTY)), // emit the buffer when the condition is met
        tap(() => (buffer = [])) // clear the buffer
        );
    });
}
const NOOP = () => undefined;
//# sourceMappingURL=PortableTextEditor.js.map